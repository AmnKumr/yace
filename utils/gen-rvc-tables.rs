#![allow(uncommon_codepoints)]
#![allow(non_camel_case_types)]
#![allow(confusable_idents)]

use yace_codegen::𝖋𝖎𝖑𝖙𝖊𝖗_𝖗𝖎𝖘𝖈𝖛_𝖒𝖆𝖗𝖐𝖊𝖗𝖘;

type 𝐚𝐬𝐬𝐦𝐛𝐥𝐞𝐫_𝐫𝐯𝟑𝟐𝐢 =
    yace::𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟯𝟮𝗶::𝐛𝐚𝐬𝐢𝐜_𝐚𝐬𝐬𝐞𝐦𝐛𝐥𝐞𝐫;
type 𝐚𝐬𝐬𝐦𝐛𝐥𝐞𝐫_𝐫𝐯𝟔𝟒𝐢 =
    yace::𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟲𝟰𝗶::𝐛𝐚𝐬𝐢𝐜_𝐚𝐬𝐬𝐞𝐦𝐛𝐥𝐞𝐫;

use yace::𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝗶𝘀𝗰_𝘃::𝒂𝒅𝒅𝒓𝒆𝒔𝒔;

use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟯𝟮𝗶::𝑪𝑷𝑼 as 𝑪𝑷𝑼_𝗿𝘃𝟯𝟮𝗶;
use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟲𝟰𝗶::𝑪𝑷𝑼 as 𝑪𝑷𝑼_𝗿𝘃𝟲𝟰𝗶;

use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟯𝟮𝗶::𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝 as 𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝_𝗿𝘃𝟯𝟮𝗶;
use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟲𝟰𝗶::𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝 as 𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝_𝗿𝘃𝟲𝟰𝗶;

use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟯𝟮𝗶::𝐨𝐩𝐞𝐫𝐚𝐧𝐝 as 𝐨𝐩𝐞𝐫𝐚𝐧𝐝_𝗿𝘃𝟯𝟮𝗶;
use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟲𝟰𝗶::𝐨𝐩𝐞𝐫𝐚𝐧𝐝 as 𝐨𝐩𝐞𝐫𝐚𝐧𝐝_𝗿𝘃𝟲𝟰𝗶;

fn main() {
    let istruction = slow_decode_compressed_instruction_rv32i(0xe6d6);
    println!(
        "{} {}",
        istruction.0,
        istruction
            .1
            .into_iter()
            .map(|op| format!("{op}"))
            .collect::<Vec<_>>()
            .join(", ")
    );
    let istruction = slow_decode_compressed_instruction_rv64i(0xe6d6);
    println!(
        "{} {}",
        istruction.0,
        istruction
            .1
            .into_iter()
            .map(|op| format!("{op}"))
            .collect::<Vec<_>>()
            .join(", ")
    );
}

// Actual decoder in main 𝔜𝔄ℭ𝔈 crate uses very fast table-based decoder.
// But since it's hard to fill these tables by hand we need slow-yet-obviously-correct one to fill these tables.
// But there are additional complexity, too: certain instructions are only supported in 𝔯𝔳32 or 𝔯𝔳64 mode!
// We are using the same 𝖋𝖎𝖑𝖙𝖊𝖗_𝖗𝖎𝖘𝖈𝖛_𝖒𝖆𝖗𝖐𝖊𝖗𝖘 macro as 𝔜𝔄ℭ𝔈 crate to solve the issue.
macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖘𝖑𝖔𝖜_𝖉𝖊𝖈𝖔𝖉𝖊_𝖈𝖔𝖒𝖕𝖗𝖊𝖘𝖘𝖊𝖉_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($( $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓻𝓮𝓼𝓽𝓻𝓲𝓬𝓽𝓲𝓸𝓷𝓼:tt
        fn $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷:ident
            -> ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮:ident, $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮:ident<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮:ident as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮:ident>)
        {
            $($𝓮𝔁𝓽𝓻𝓪_𝓬𝓸𝓭𝓮:tt)*
        }
      )*) => {
        $(
            𝖋𝖎𝖑𝖙𝖊𝖗_𝖗𝖎𝖘𝖈𝖛_𝖒𝖆𝖗𝖐𝖊𝖗𝖘! {
                𝖉𝖊𝖋𝖎𝖓𝖊_𝖘𝖑𝖔𝖜_𝖉𝖊𝖈𝖔𝖉𝖊_𝖈𝖔𝖒𝖕𝖗𝖊𝖘𝖘𝖊𝖉_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
                    $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓻𝓮𝓼𝓽𝓻𝓲𝓬𝓽𝓲𝓸𝓷𝓼
                    fn $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷(machine_code: u16)
                        -> ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮, Vec<$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>)
                    {
                        $($𝓮𝔁𝓽𝓻𝓪_𝓬𝓸𝓭𝓮)*
                        match (machine_code >> 15,
                               machine_code >> 14 & 1,
                               machine_code >> 13 & 1,
                               machine_code >> 12 & 1,
                               machine_code >> 11 & 1,
                               machine_code >> 10 & 1,
                               machine_code >> 9 & 1,
                               machine_code >> 8 & 1,
                               machine_code >> 7 & 1,
                               machine_code >> 6 & 1,
                               machine_code >> 5 & 1,
                               machine_code >> 4 & 1,
                               machine_code >> 3 & 1,
                               machine_code >> 2 & 1,
                               machine_code >> 1 & 1,
                               machine_code & 1) {
                            (0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new()),
                            (0,  0,  0, i5, i4, i9, i8, i7, i6, i2, i3, r2, r1, r0,  0,  0) => {
                                let imm = i9<<9 | i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                            (0,  0,  1, i5, i4, i3, s2, s1, s0, i7, i6, r2, r1, r0,  0,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔩𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }
                            (0,  1,  0, i5, i4, i3, s2, s1, s0, i2, i6, r2, r1, r0,  0,  0) => {
                                let imm = i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔩𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }
                    Ξ𝔯𝔳32[  (0,  1,  0, i5, i4, i3, s2, s1, s0, i2, i6, r2, r1, r0,  0,  0) => {
                                let imm = i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔩𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }]
                    Ξ𝔯𝔳64[  (0,  1,  0, i5, i4, i3, s2, s1, s0, i7, i6, r2, r1, r0,  0,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔩𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }]
                            (1,  0,  1, i5, i4, i3, s2, s1, s0, i7, i6, r2, r1, r0,  0,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔰𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }
                            (1,  1,  0, i5, i4, i3, s2, s1, s0, i2, i6, r2, r1, r0,  0,  0) => {
                                let imm = i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }
                    Ξ𝔯𝔳32[  (1,  1,  1, i5, i4, i3, s2, s1, s0, i2, i6, r2, r1, r0,  0,  0) => {
                                let imm = i6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔰𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }]
                    Ξ𝔯𝔳64[  (1,  1,  1, i5, i4, i3, s2, s1, s0, i7, i6, r2, r1, r0,  0,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }]
                            (0,  0,  0,_i5,  0,  0,  0,  0,  0,_i4,_i3,_i2,_i1,_i0,  0,  1) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔫𝔬𝔭,
                                 Vec::new()),
                            (0,  0,  0, i5, r4, r3, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = (i5 as i32 * -1)<<5 | (i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                    Ξ𝔯𝔳32[  (0,  0,  1,i11, i4, i9, i8,i10, i6, i7, i3, i2, i1, i5,  0,  1) => {
                                let imm = (i11 as i32 * -1)<<11 | (i10<<10 | i9<<9 | i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐣𝐮𝐦𝐩_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔧𝔞𝔩,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵1.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔧𝔲𝔪𝔭_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }]
                    Ξ𝔯𝔳64[  (0,  0,  0,_i5,  0,  0,  0,  0,  0,_i4,_i3,_i2,_i1,_i0,  0,  1) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new()),
                            (0,  0,  1, i5, r4, r3, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = (i5 as i32 * -1)<<5 | (i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔦𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }]
                            (0,  1,  0, i5, r4, r3, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = (i5 as i32 * -1)<<5 | (i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                            (0,  1,  1, i9,  0,  0,  0,  1,  0, i4, i6, i8, i7, i5,  0,  1) => {
                                let imm = (i9 as i32 * -1)<<9 | (i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                            (0,  1,  1,i17, r4, r3, r2, r1, r0,i𝟭𝟲,i15,i14,i13,i12,  0,  1) => {
                                let imm = (i17 as i32 * -1)<<17 | (i𝟭𝟲 as i32)<<16 | (i15 as i32)<<15 | (i14 as i32)<<14 | (i13 as i32)<<13 | (i12 as i32)<<12;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐮𝐩𝐩𝐞𝐫_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔩𝔲𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔲𝔭𝔭𝔢𝔯_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                    Ξ𝔯𝔳32[  (1,  0,  0,  1,  0,  0,_r2,_r1,_r0,_i4,_i3,_i2,_i1,_i0,  0,  1) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new()),]
                            (1,  0,  0, i5,  0,  0, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐬𝐡𝐢𝐟𝐭_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔯𝔩𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔥𝔦𝔣𝔱_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                    Ξ𝔯𝔳32[  (1,  0,  0,  1,  0,  1,_r2,_r1,_r0,_i4,_i3,_i2,_i1,_i0,  0,  1) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new()),]
                            (1,  0,  0, i5,  0,  1, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐬𝐡𝐢𝐟𝐭_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔯𝔞𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔥𝔦𝔣𝔱_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                            (1,  0,  0, i5,  1,  0, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = (i5 as i32 * -1)<<5 | (i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔫𝔡𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                            (1,  0,  0,  0,  1,  1, r2, r1, r0,  0,  0, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔲𝔟,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())])
                            }
                            (1,  0,  0,  0,  1,  1, r2, r1, r0,  0,  1, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔵𝔬𝔯,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())])
                            }
                            (1,  0,  0,  0,  1,  1, r2, r1, r0,  1,  0, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔬𝔯,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())])
                            }
                            (1,  0,  0,  0,  1,  1, r2, r1, r0,  1,  1, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔫𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())])
                            }
                    Ξ𝔯𝔳64[  (1,  0,  0,  1,  1,  1, r2, r1, r0,  0,  0, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔲𝔟𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())])
                            }
                            (1,  0,  0,  1,  1,  1, r2, r1, r0,  0,  1, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())])
                            }]
                            (0,  0,  1,i11, i4, i9, i8,i10, i6, i7, i3, i2, i1, i5,  0,  1) => {
                                let imm = (i11 as i32 * -1)<<11 | (i10<<10 | i9<<9 | i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐣𝐮𝐦𝐩_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔧𝔞𝔩,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔧𝔲𝔪𝔭_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                            (1,  1,  0, i8, i4, i3, s2, s1, s0, i7, i6, i2, i1, i5,  0,  1) => {
                                let imm = (i8 as i32 * -1)<<8 | (i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐛𝐫𝐚𝐧𝐜𝐡_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔟𝔢𝔮,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs1.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔟𝔯𝔞𝔫𝔠𝔥_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                            (1,  1,  1, i8, i4, i3, s2, s1, s0, i7, i6, i2, i1, i5,  0,  1) => {
                                let imm = (i8 as i32 * -1)<<8 | (i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐛𝐫𝐚𝐧𝐜𝐡_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔟𝔫𝔢,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs1.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔟𝔯𝔞𝔫𝔠𝔥_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                    Ξ𝔯𝔳32[  (0,  0,  0,  1,_r4,_r3,_r2,_r1,_r0,_i4,_i3,_i2,_i1,_i0,  1,  0) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new()),]
                            (0,  0,  0, i5, r4, r3, r2, r1, r0, i4, i3, i2, i1, i0,  1,  0) => {
                                let imm = i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐬𝐡𝐢𝐟𝐭_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔩𝔩𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔥𝔦𝔣𝔱_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())])
                            }
                            (0,  0,  1, i5, r4, r3, r2, r1, r0, i4, i3, i8, i7, i6,  1,  0) => {
                                let imm = i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔩𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }
                            (0,  1,  0, i5, r4, r3, r2, r1, r0, i4, i3, i2, i7, i6,  1,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔩𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }
                    Ξ𝔯𝔳32[  (0,  1,  1, i5, r4, r3, r2, r1, r0, i4, i3, i2, i7, i6,  1,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔩𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }]
                    Ξ𝔯𝔳64[  (0,  1,  1, i5, r4, r3, r2, r1, r0, i4, i3, i8, i7, i6,  1,  0) => {
                                let imm = i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔩𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }]
                            (1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new()),
                            (1,  0,  0,  0, s4, s3, s2, s1, s0,  0,  0,  0,  0,  0,  1,  0) => {
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = 0.try_into();
                                let rs1 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔧𝔞𝔩𝔯,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }
                            (1,  0,  0,  0, r4, r3, r2, r1, r0, s4, s3, s2, s1, s0,  1,  0) => {
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())])
                            }
                            (1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔢𝔟𝔯𝔢𝔞𝔨,
                                 Vec::new()),
                            (1,  0,  0,  1, s4, s3, s2, s1, s0,  0,  0,  0,  0,  0,  1,  0) => {
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = 0.try_into();
                                let rs1 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔧𝔞𝔩𝔯,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵1.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }
                            (1,  0,  0,  1, r4, r3, r2, r1, r0, s4, s3, s2, s1, s0,  1,  0) => {
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())])
                            }
                            (1,  0,  1, i5, i4, i3, i8, i7, i6, s4, s3, s2, s1, s0,  1,  0) => {
                                let imm = i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔰𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }
                            (1,  1,  0, i5, i4, i3, i2, i7, i6, s4, s3, s2, s1, s0,  1,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }
                    Ξ𝔯𝔳32[  (1,  1,  1, i5, i4, i3, i2, i7, i6, s4, s3, s2, s1, s0,  1,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔰𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }]
                    Ξ𝔯𝔳64[  (1,  1,  1, i5, i4, i3, i8, i7, i6, s4, s3, s2, s1, s0,  1,  0) => {
                                let imm = i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})])
                            }]
                            _ => ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                  Vec::new())
                        }
                    }
                }
            }
         )*
    };
    ($( $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓻𝓮𝓼𝓽𝓻𝓲𝓬𝓽𝓲𝓸𝓷𝓼:tt
        fn $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷:ident $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt
            -> $𝓸𝓾𝓽𝓹𝓾𝓽_𝓽𝔂𝓹𝓮:tt
        $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓫𝓸𝓭𝔂:tt
      )*) => {
        $(
            fn $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷 $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼
                -> $𝓸𝓾𝓽𝓹𝓾𝓽_𝓽𝔂𝓹𝓮
            $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓫𝓸𝓭𝔂
         )*
    };
}

𝖉𝖊𝖋𝖎𝖓𝖊_𝖘𝖑𝖔𝖜_𝖉𝖊𝖈𝖔𝖉𝖊_𝖈𝖔𝖒𝖕𝖗𝖊𝖘𝖘𝖊𝖉_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
    [𝔯𝔳32𝔦]
    fn slow_decode_compressed_instruction_rv32i -> (𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝_𝗿𝘃𝟯𝟮𝗶, 𝐨𝐩𝐞𝐫𝐚𝐧𝐝_𝗿𝘃𝟯𝟮𝗶<𝐚𝐬𝐬𝐦𝐛𝐥𝐞𝐫_𝐫𝐯𝟑𝟐𝐢 as 𝑪𝑷𝑼_𝗿𝘃𝟯𝟮𝗶>) {
    }

    [𝔯𝔳64𝔦]
    fn slow_decode_compressed_instruction_rv64i -> (𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝_𝗿𝘃𝟲𝟰𝗶, 𝐨𝐩𝐞𝐫𝐚𝐧𝐝_𝗿𝘃𝟲𝟰𝗶<𝐚𝐬𝐬𝐦𝐛𝐥𝐞𝐫_𝐫𝐯𝟔𝟒𝐢 as 𝑪𝑷𝑼_𝗿𝘃𝟲𝟰𝗶>){
    }
}
