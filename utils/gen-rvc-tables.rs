#![allow(uncommon_codepoints)]
#![allow(non_camel_case_types)]
#![allow(confusable_idents)]

use yace_codegen::𝖋𝖎𝖑𝖙𝖊𝖗_𝖗𝖎𝖘𝖈𝖛_𝖒𝖆𝖗𝖐𝖊𝖗𝖘;

type 𝐚𝐬𝐬𝐦𝐛𝐥𝐞𝐫_𝐫𝐯𝟑𝟐𝐢 =
    yace::𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟯𝟮𝗶::𝐛𝐚𝐬𝐢𝐜_𝐚𝐬𝐬𝐞𝐦𝐛𝐥𝐞𝐫;
type 𝐚𝐬𝐬𝐦𝐛𝐥𝐞𝐫_𝐫𝐯𝟔𝟒𝐢 =
    yace::𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟲𝟰𝗶::𝐛𝐚𝐬𝐢𝐜_𝐚𝐬𝐬𝐞𝐦𝐛𝐥𝐞𝐫;

use yace::𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝗶𝘀𝗰_𝘃::𝒂𝒅𝒅𝒓𝒆𝒔𝒔;

use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟯𝟮𝗶::𝑪𝑷𝑼 as 𝑪𝑷𝑼_𝗿𝘃𝟯𝟮𝗶;
use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟲𝟰𝗶::𝑪𝑷𝑼 as 𝑪𝑷𝑼_𝗿𝘃𝟲𝟰𝗶;

use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟯𝟮𝗶::𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝 as 𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝_𝗿𝘃𝟯𝟮𝗶;
use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟲𝟰𝗶::𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝 as 𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝_𝗿𝘃𝟲𝟰𝗶;

use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟯𝟮𝗶::𝐨𝐩𝐞𝐫𝐚𝐧𝐝 as 𝐨𝐩𝐞𝐫𝐚𝐧𝐝_𝗿𝘃𝟯𝟮𝗶;
use yace::𝗱𝗶𝘀𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝗿𝘃𝟲𝟰𝗶::𝐨𝐩𝐞𝐫𝐚𝐧𝐝 as 𝐨𝐩𝐞𝐫𝐚𝐧𝐝_𝗿𝘃𝟲𝟰𝗶;

fn main() {
    let istruction = slow_decode_compressed_instruction_rv32i(0xe6d6);
    println!(
        "{} {}",
        istruction.0,
        istruction
            .1
            .into_iter()
            .map(|op| format!("{op}"))
            .collect::<Vec<_>>()
            .join(", ")
    );
    let istruction = slow_decode_compressed_instruction_rv64i(0xe6d6);
    println!(
        "{} {}",
        istruction.0,
        istruction
            .1
            .into_iter()
            .map(|op| format!("{op}"))
            .collect::<Vec<_>>()
            .join(", ")
    );
    for encoded_byte in u8::MIN..=u8::MAX {
        let encoded_parcel = ((encoded_byte & 0xfc) as u16) << 8 | 0x3fc | (encoded_byte & 0x03) as u16;
        let instruction_rv32 = slow_decode_compressed_instruction_rv32i(encoded_parcel);
        let instruction_rv64 = slow_decode_compressed_instruction_rv64i(encoded_parcel);
        for ignored_byte in u8::MIN..u8::MAX {
            let encoded_alt_parcel =
                ((encoded_byte & 0xfc) as u16) << 8 | (ignored_byte as u16) << 2 | (encoded_byte & 0x03) as u16;
            let alt_instruction_rv32 = slow_decode_compressed_instruction_rv32i(encoded_alt_parcel);
            let alt_instruction_rv64 = slow_decode_compressed_instruction_rv64i(encoded_alt_parcel);
            if instruction_rv32.2 != alt_instruction_rv32.2 {
                println!("rv32: 0b{:016b} {} {:?}", encoded_parcel, instruction_rv32.0, instruction_rv32.2);
                println!("rv32: 0b{:016b} {} {:?}", encoded_alt_parcel, alt_instruction_rv32.0, alt_instruction_rv32.2);
            }
            if instruction_rv64.2 != alt_instruction_rv64.2 {
                println!("rv64: 0b{:016b} {} {:?}", encoded_parcel, instruction_rv64.0, instruction_rv64.2);
                println!("rv64: 0b{:016b} {} {:?}", encoded_alt_parcel, alt_instruction_rv64.0, alt_instruction_rv64.2);
            }
        }
    }
}

// Actual decoder in main 𝔜𝔄ℭ𝔈 crate uses very fast table-based decoder.
// But since it's hard to fill these tables by hand we need slow-yet-obviously-correct one to fill these tables.
// But there are additional complexity, too: certain instructions are only supported in 𝔯𝔳32 or 𝔯𝔳64 mode!
// We are using the same 𝖋𝖎𝖑𝖙𝖊𝖗_𝖗𝖎𝖘𝖈𝖛_𝖒𝖆𝖗𝖐𝖊𝖗𝖘 macro as 𝔜𝔄ℭ𝔈 crate to solve the issue.
macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖘𝖑𝖔𝖜_𝖉𝖊𝖈𝖔𝖉𝖊_𝖈𝖔𝖒𝖕𝖗𝖊𝖘𝖘𝖊𝖉_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($( $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓻𝓮𝓼𝓽𝓻𝓲𝓬𝓽𝓲𝓸𝓷𝓼:tt
        fn $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷:ident
            -> ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮:ident, $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮:ident<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮:ident as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮:ident>)
        {
            $($𝓮𝔁𝓽𝓻𝓪_𝓬𝓸𝓭𝓮:tt)*
        }
      )*) => {
        $(
            𝖋𝖎𝖑𝖙𝖊𝖗_𝖗𝖎𝖘𝖈𝖛_𝖒𝖆𝖗𝖐𝖊𝖗𝖘! {
                𝖉𝖊𝖋𝖎𝖓𝖊_𝖘𝖑𝖔𝖜_𝖉𝖊𝖈𝖔𝖉𝖊_𝖈𝖔𝖒𝖕𝖗𝖊𝖘𝖘𝖊𝖉_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
                    $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓻𝓮𝓼𝓽𝓻𝓲𝓬𝓽𝓲𝓸𝓷𝓼
                    fn $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷(machine_code: u16)
                        -> ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮, Vec<$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>, 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩, i32, i32)
                    {
                        $($𝓮𝔁𝓽𝓻𝓪_𝓬𝓸𝓭𝓮)*
                        match (machine_code >> 15,
                               machine_code >> 14 & 1,
                               machine_code >> 13 & 1,
                               machine_code >> 12 & 1,
                               machine_code >> 11 & 1,
                               machine_code >> 10 & 1,
                               machine_code >> 9 & 1,
                               machine_code >> 8 & 1,
                               machine_code >> 7 & 1,
                               machine_code >> 6 & 1,
                               machine_code >> 5 & 1,
                               machine_code >> 4 & 1,
                               machine_code >> 3 & 1,
                               machine_code >> 2 & 1,
                               machine_code >> 1 & 1,
                               machine_code & 1) {
                            (0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new(),
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦4𝔰𝔭𝔫,
                                 0,
                                 0),
                            (0,  0,  0, i5, i4, i9, i8, i7, i6, i2, i3, r2, r1, r0,  0,  0) => {
                                let imm = i9<<9 | i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦4𝔰𝔭𝔫,
                                 imm.unwrap().into(),
                                 0)
                            }
                            (0,  0,  1, i5, i4, i3, s2, s1, s0, i7, i6, r2, r1, r0,  0,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔩𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔩𝔡,
                                 imm.unwrap().into(),
                                 0)
                            }
                            (0,  1,  0, i5, i4, i3, s2, s1, s0, i2, i6, r2, r1, r0,  0,  0) => {
                                let imm = i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔩𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔴,
                                 imm.unwrap().into(),
                                 0)
                            }
                    Ξ𝔯𝔳32[  (0,  1,  0, i5, i4, i3, s2, s1, s0, i2, i6, r2, r1, r0,  0,  0) => {
                                let imm = i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔩𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔩𝔴,
                                 imm.unwrap().into(),
                                 0)
                            }]
                    Ξ𝔯𝔳64[  (0,  1,  0, i5, i4, i3, s2, s1, s0, i7, i6, r2, r1, r0,  0,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔩𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔩𝔴,
                                 imm.unwrap().into(),
                                 0)
                            }]
                            (1,  0,  0,  _,  _,  _,  _,  _,  _,  _,  _,  _,  _,  _,  0,  0) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new(),
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔯𝔢𝔰𝔢𝔯𝔳𝔢𝔡,
                                 0,
                                 0),
                            (1,  0,  1, i5, i4, i3, s2, s1, s0, i7, i6, r2, r1, r0,  0,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔰𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔰𝔡,
                                 imm.unwrap().into(),
                                 0)
                            }
                            (1,  1,  0, i5, i4, i3, s2, s1, s0, i2, i6, r2, r1, r0,  0,  0) => {
                                let imm = i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔰𝔴,
                                 imm.unwrap().into(),
                                 0)
                            }
                    Ξ𝔯𝔳32[  (1,  1,  1, i5, i4, i3, s2, s1, s0, i2, i6, r2, r1, r0,  0,  0) => {
                                let imm = i6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔰𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔰𝔴,
                                 imm.unwrap().into(),
                                 0)
                            }]
                    Ξ𝔯𝔳64[  (1,  1,  1, i5, i4, i3, s2, s1, s0, i7, i6, r2, r1, r0,  0,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔰𝔴,
                                 imm.unwrap().into(),
                                 0)
                            }]
                            (0,  0,  0, i5,  0,  0,  0,  0,  0,_i4,_i3,_i2,_i1,_i0,  0,  1) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔫𝔬𝔭,
                                 Vec::new(),
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_00 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_00 },
                                 0,
                                 0),
                            (0,  0,  0, i5, r4, r3, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = (i5 as i32 * -1)<<5 | (i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 match (i5, r4, r3) {
                                     (0, 0, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_00,
                                     (0, 0, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_01,
                                     (0, 1, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_10,
                                     (0, 1, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_11,
                                     (1, 0, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_00,
                                     (1, 0, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_01,
                                     (1, 1, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_10,
                                     (1, 1, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_11,
                                     _ => panic!("Internal error"),
                                 },
                                 imm.unwrap().into(),
                                 (r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0).into())
                            }
                    Ξ𝔯𝔳32[  (0,  0,  1,i11, i4, i9, i8,i10, i6, i7, i3, i2, i1, i5,  0,  1) => {
                                let imm = (i11 as i32 * -1)<<11 | (i10<<10 | i9<<9 | i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐣𝐮𝐦𝐩_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔧𝔞𝔩,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵1.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔧𝔲𝔪𝔭_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 match (i11, i4, i9) {
                                     (0, 0, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_00,
                                     (0, 0, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_01,
                                     (0, 1, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_10,
                                     (0, 1, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_11,
                                     (1, 0, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_00,
                                     (1, 0, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_01,
                                     (1, 1, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_10,
                                     (1, 1, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_11,
                                     _ => panic!("Internal error"),
                                 },
                                 imm.unwrap().into(),
                                 0)
                            }]
                    Ξ𝔯𝔳64[  (0,  0,  1, i5,  0,  0,  0,  0,  0,_i4,_i3,_i2,_i1,_i0,  0,  1) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new(),
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_00 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_00 },
                                 0,
                                 0),
                            (0,  0,  1, i5, r4, r3, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = (i5 as i32 * -1)<<5 | (i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔦𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 match (i5, r4, r3) {
                                     (0, 0, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_00,
                                     (0, 0, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_01,
                                     (0, 1, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_10,
                                     (0, 1, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_11,
                                     (1, 0, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_00,
                                     (1, 0, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_01,
                                     (1, 1, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_10,
                                     (1, 1, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_11,
                                     _ => panic!("Internal error"),
                                 },
                                 imm.unwrap().into(),
                                 (r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0).into())
                            }]
                            (0,  1,  0, i5, r4, r3, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = (i5 as i32 * -1)<<5 | (i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢 },
                                 imm.unwrap().into(),
                                 (r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0).into())
                            }
                            (0,  1,  1,  0, r4, r3,_r2,_r1,_r0,  0,  0,  0,  0,  0,  0,  1) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new(),
                                 match (r4, r3) {
                                     (0, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_00,
                                     (0, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_01,
                                     (1, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_10,
                                     (1, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_11,
                                     _ => panic!("Internal error"),
                                 },
                                 0,
                                 0),
                            (0,  1,  1, i9,  0,  0,  0,  1,  0, i4, i6, i8, i7, i5,  0,  1) => {
                                let imm = (i9 as i32 * -1)<<9 | (i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 if i9 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_00 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_00 },
                                 imm.unwrap().into(),
                                 0)
                            }
                            (0,  1,  1,i17, r4, r3, r2, r1, r0,i𝟭𝟲,i15,i14,i13,i12,  0,  1) => {
                                let imm = (i17 as i32 * -1)<<17 | (i𝟭𝟲 as i32)<<16 | (i15 as i32)<<15 | (i14 as i32)<<14 | (i13 as i32)<<13 | (i12 as i32)<<12;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐮𝐩𝐩𝐞𝐫_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔩𝔲𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔲𝔭𝔭𝔢𝔯_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 match (i17, r4, r3) {
                                     (0, 0, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_00,
                                     (0, 0, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_01,
                                     (0, 1, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_10,
                                     (0, 1, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_11,
                                     (1, 0, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_00,
                                     (1, 0, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_01,
                                     (1, 1, 0) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_10,
                                     (1, 1, 1) => 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔲𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_11,
                                     _ => panic!("Internal error"),
                                 },
                                 imm.unwrap().into(),
                                 (r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0).into())
                            }
                    Ξ𝔯𝔳32[  (1,  0,  0,  1,  0,  0,_r2,_r1,_r0,_i4,_i3,_i2,_i1,_i0,  0,  1) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new(),
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔰𝔯𝔩𝔦_𝔥𝔦𝔤𝔥,
                                 0,
                                 0),]
                            (1,  0,  0, i5,  0,  0, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐬𝐡𝐢𝐟𝐭_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔯𝔩𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔥𝔦𝔣𝔱_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔰𝔯𝔩𝔦_𝔥𝔦𝔤𝔥 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔰𝔯𝔩𝔦_𝔩𝔬𝔴 },
                                 imm.unwrap().into(),
                                 0)
                            }
                    Ξ𝔯𝔳32[  (1,  0,  0,  1,  0,  1,_r2,_r1,_r0,_i4,_i3,_i2,_i1,_i0,  0,  1) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new(),
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔰𝔯𝔞𝔦_𝔥𝔦𝔤𝔥,
                                 0,
                                 0),]
                            (1,  0,  0, i5,  0,  1, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐬𝐡𝐢𝐟𝐭_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔯𝔞𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔥𝔦𝔣𝔱_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔰𝔯𝔞𝔦_𝔥𝔦𝔤𝔥 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔰𝔯𝔞𝔦_𝔩𝔬𝔴 },
                                 imm.unwrap().into(),
                                 0)
                            }
                            (1,  0,  0, i5,  1,  0, r2, r1, r0, i4, i3, i2, i1, i0,  0,  1) => {
                                let imm = (i5 as i32 * -1)<<5 | (i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔫𝔡𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔫𝔡𝔦_𝔥𝔦𝔤𝔥 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔫𝔡𝔦_𝔩𝔬𝔴 },
                                 imm.unwrap().into(),
                                 0)
                            }
                            (1,  0,  0,  0,  1,  1, r2, r1, r0,  0,  0, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔲𝔟,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔫𝔡_𝔬𝔯_𝔰𝔲𝔟_𝔵𝔬𝔯,
                                 0,
                                 0)
                            }
                            (1,  0,  0,  0,  1,  1, r2, r1, r0,  0,  1, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔵𝔬𝔯,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔫𝔡_𝔬𝔯_𝔰𝔲𝔟_𝔵𝔬𝔯,
                                 0,
                                 0)
                            }
                            (1,  0,  0,  0,  1,  1, r2, r1, r0,  1,  0, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔬𝔯,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔫𝔡_𝔬𝔯_𝔰𝔲𝔟_𝔵𝔬𝔯,
                                 0,
                                 0)
                            }
                            (1,  0,  0,  0,  1,  1, r2, r1, r0,  1,  1, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔫𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔫𝔡_𝔬𝔯_𝔰𝔲𝔟_𝔵𝔬𝔯,
                                 0,
                                 0)
                            }
                    Ξ𝔯𝔳64[  (1,  0,  0,  1,  1,  1, r2, r1, r0,  0,  0, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔲𝔟𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔴_𝔰𝔲𝔟𝔴,
                                 0,
                                 0)
                            }
                            (1,  0,  0,  1,  1,  1, r2, r1, r0,  0,  1, s2, s1, s0,  0,  1) => {
                                let rd = 8 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = 8 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔴_𝔰𝔲𝔟𝔴,
                                 0,
                                 0)
                            }]
                            (1,  0,  0,  1,  1,  1,_r2,_r1,_r0,_x1,_x0,_s2,_s1,_s0,  0,  1) => {
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new(),
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡𝔴_𝔰𝔲𝔟𝔴,
                                 0,
                                 0)
                            }
                            (0,  0,  1,i11, i4, i9, i8,i10, i6, i7, i3, i2, i1, i5,  0,  1) => {
                                let imm = (i11 as i32 * -1)<<11 | (i10<<10 | i9<<9 | i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐣𝐮𝐦𝐩_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔧𝔞𝔩,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔧𝔲𝔪𝔭_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔧,
                                 imm.unwrap().into(),
                                 0)
                            }
                            (1,  1,  0, i8, i4, i3, s2, s1, s0, i7, i6, i2, i1, i5,  0,  1) => {
                                let imm = (i8 as i32 * -1)<<8 | (i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐛𝐫𝐚𝐧𝐜𝐡_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔟𝔢𝔮,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs1.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔟𝔯𝔞𝔫𝔠𝔥_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔟𝔢𝔮𝔷,
                                 imm.unwrap().into(),
                                 0)
                            }
                            (1,  1,  1, i8, i4, i3, s2, s1, s0, i7, i6, i2, i1, i5,  0,  1) => {
                                let imm = (i8 as i32 * -1)<<8 | (i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1) as i32;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐛𝐫𝐚𝐧𝐜𝐡_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs1 = 8 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔟𝔫𝔢,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs1.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔟𝔯𝔞𝔫𝔠𝔥_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔟𝔫𝔢𝔷,
                                 imm.unwrap().into(),
                                 0)
                            }
                    Ξ𝔯𝔳32[  (0,  0,  0,  1,_r4,_r3,_r2,_r1,_r0,_i4,_i3,_i2,_i1,_i0,  1,  0) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new(),
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔰𝔩𝔩𝔦_𝔥𝔦𝔤𝔥,
                                 0,
                                 0),]
                            (0,  0,  0, i5, r4, r3, r2, r1, r0, i4, i3, i2, i1, i0,  1,  0) => {
                                let imm = i5<<5 | i4<<4 | i3<<3 | i2<<2 | i1<<1 | i0;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐬𝐡𝐢𝐟𝐭_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔩𝔩𝔦,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔥𝔦𝔣𝔱_𝔦𝔪𝔪𝔢𝔡𝔦𝔞𝔱𝔢_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(imm.unwrap())],
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔰𝔩𝔩𝔦_𝔥𝔦𝔤𝔥 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔰𝔩𝔩𝔦_𝔩𝔬𝔴 },
                                 imm.unwrap().into(),
                                 (r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0).into())
                            }
                            (0,  0,  1, i5, r4, r3, r2, r1, r0, i4, i3, i8, i7, i6,  1,  0) => {
                                let imm = i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔩𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔩𝔡𝔰𝔭_𝔥𝔦𝔤𝔥 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔩𝔡𝔰𝔭_𝔩𝔬𝔴 },
                                 imm.unwrap().into(),
                                 (r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0).into())
                            }
                            (0,  1,  0, i5, r4, r3, r2, r1, r0, i4, i3, i2, i7, i6,  1,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔩𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔴𝔰𝔭_𝔥𝔦𝔤𝔥 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔩𝔴𝔰𝔭_𝔩𝔬𝔴 },
                                 imm.unwrap().into(),
                                 (r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0).into())
                            }
                    Ξ𝔯𝔳32[  (0,  1,  1, i5, r4, r3, r2, r1, r0, i4, i3, i2, i7, i6,  1,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔩𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔩𝔴𝔰𝔭_𝔥𝔦𝔤𝔥 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔩𝔴𝔰𝔭_𝔩𝔬𝔴 },
                                 imm.unwrap().into(),
                                 (r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0).into())
                            }]
                    Ξ𝔯𝔳64[  (0,  1,  1, i5,  0,  0,  0,  0,  0,_i4,_i3,_i8,_i7,_i6,  1,  0) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new(),
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔩𝔴𝔰𝔭_𝔥𝔦𝔤𝔥 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔩𝔴𝔰𝔭_𝔩𝔬𝔴 },
                                 0,
                                 0),
                            (0,  1,  1, i5, r4, r3, r2, r1, r0, i4, i3, i8, i7, i6,  1,  0) => {
                                let imm = i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔩𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 if i5 == 1 { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔩𝔴𝔰𝔭_𝔥𝔦𝔤𝔥 } else { 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔩𝔴𝔰𝔭_𝔩𝔬𝔴 },
                                 imm.unwrap().into(),
                                 (r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0).into())
                            }]
                            (1,  0,  0,  0,  0,  0,  0,  0,  0,_s4,_s3,_s2,_s1,_s0,  1,  0) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                 Vec::new(),
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔪𝔳,
                                 0,
                                 0),
                            (1,  0,  0,  0, s4, s3, s2, s1, s0,  0,  0,  0,  0,  0,  1,  0) => {
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = 0.try_into();
                                let rs1 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔧𝔞𝔩𝔯,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔪𝔳,
                                 0,
                                 (s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0).into())
                            }
                            (1,  0,  0,  0, r4, r3, r2, r1, r0, s4, s3, s2, s1, s0,  1,  0) => {
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵0.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔪𝔳,
                                 0,
                                 (r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0).into())
                            }
                            (1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0) =>
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔢𝔟𝔯𝔢𝔞𝔨,
                                 Vec::new(),
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡,
                                 0,
                                 0),
                            (1,  0,  0,  1, s4, s3, s2, s1, s0,  0,  0,  0,  0,  0,  1,  0) => {
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = 0.try_into();
                                let rs1 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs1: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs1.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔧𝔞𝔩𝔯,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵1.into()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔰𝔬𝔲𝔯𝔠𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:rs1.unwrap(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡,
                                 0,
                                 (s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0).into())
                            }
                            (1,  0,  0,  1, r4, r3, r2, r1, r0, s4, s3, s2, s1, s0,  1,  0) => {
                                let rd = r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0;
                                let rd: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rd.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔞𝔡𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rd.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap())],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔞𝔡𝔡,
                                 0,
                                 (r4<<4 | r3<<3 | r2<<2 | r1<<1 | r0).into())
                            }
                            (1,  0,  1, i5, i4, i3, i8, i7, i6, s4, s3, s2, s1, s0,  1,  0) => {
                                let imm = i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔰𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔰𝔡𝔰𝔭,
                                 imm.unwrap().into(),
                                 0)
                            }
                            (1,  1,  0, i5, i4, i3, i2, i7, i6, s4, s3, s2, s1, s0,  1,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔰𝔴𝔰𝔭,
                                 imm.unwrap().into(),
                                 0)
                            }
                    Ξ𝔯𝔳32[  (1,  1,  1, i5, i4, i3, i2, i7, i6, s4, s3, s2, s1, s0,  1,  0) => {
                                let imm = i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3 | i2<<2;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐟𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔣𝔰𝔴,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔣𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔰𝔴𝔰𝔭,
                                 imm.unwrap().into(),
                                 0)
                            }]
                    Ξ𝔯𝔳64[  (1,  1,  1, i5, i4, i3, i8, i7, i6, s4, s3, s2, s1, s0,  1,  0) => {
                                let imm = i8<<8 | i7<<7 | i6<<6 | i5<<5 | i4<<4 | i3<<3;
                                let imm: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐝𝐞𝐬𝐭𝐢𝐧𝐚𝐭𝐢𝐨𝐧_𝐢𝐦𝐦𝐞𝐝𝐢𝐚𝐭𝐞, _> = imm.try_into();
                                let rs2 = s4<<4 | s3<<3 | s2<<2 | s1<<1 | s0;
                                let rs2: Result<<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_𝐧𝐮𝐦𝐞𝐫𝐢𝐜, _> = rs2.try_into();
                                ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔰𝔡,
                                 vec![$𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔤𝔭_𝔯𝔢𝔤𝔦𝔰𝔱𝔢𝔯_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(rs2.unwrap()),
                                      $𝓸𝓹𝓮𝓻𝓪𝓷𝓭_𝓽𝔂𝓹𝓮::<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>::𝔡𝔢𝔰𝔱𝔦𝔫𝔞𝔱𝔦𝔬𝔫_𝔞𝔡𝔡𝔯𝔢𝔰𝔰_𝔬𝔭𝔢𝔯𝔞𝔫𝔡(𝒂𝒅𝒅𝒓𝒆𝒔𝒔{𝖻𝖺𝗌𝖾:<$𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮 as $𝓒𝓟𝓤_𝓽𝔂𝓹𝓮>::𝔵2.into(), 𝖽𝗂𝗌𝗉:imm.unwrap()})],
                                 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔣𝔰𝔴𝔰𝔭,
                                 imm.unwrap().into(),
                                 0)
                            }]
                            _ => ($𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓴𝓲𝓷𝓭_𝓽𝔂𝓹𝓮::𝔲𝔫𝔦𝔪𝔭,
                                  Vec::new(),
                                  𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩::𝔠_𝔲𝔫𝔯𝔢𝔠𝔬𝔤𝔫𝔦𝔷𝔢𝔡,
                                  0,
                                  0)
                        }
                    }
                }
            }
         )*
    };
    ($( $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓻𝓮𝓼𝓽𝓻𝓲𝓬𝓽𝓲𝓸𝓷𝓼:tt
        fn $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷:ident $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt
            -> $𝓸𝓾𝓽𝓹𝓾𝓽_𝓽𝔂𝓹𝓮:tt
        $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓫𝓸𝓭𝔂:tt
      )*) => {
        $(
            fn $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷 $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼
                -> $𝓸𝓾𝓽𝓹𝓾𝓽_𝓽𝔂𝓹𝓮
            $𝓼𝓵𝓸𝔀_𝓭𝓮𝓬𝓸𝓭𝓮_𝓬𝓸𝓶𝓹𝓻𝓮𝓼𝓼𝓮𝓭_𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓫𝓸𝓭𝔂
         )*
    };
}

𝖉𝖊𝖋𝖎𝖓𝖊_𝖘𝖑𝖔𝖜_𝖉𝖊𝖈𝖔𝖉𝖊_𝖈𝖔𝖒𝖕𝖗𝖊𝖘𝖘𝖊𝖉_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
    [𝔯𝔳32𝔦]
    fn slow_decode_compressed_instruction_rv32i -> (𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝_𝗿𝘃𝟯𝟮𝗶, 𝐨𝐩𝐞𝐫𝐚𝐧𝐝_𝗿𝘃𝟯𝟮𝗶<𝐚𝐬𝐬𝐦𝐛𝐥𝐞𝐫_𝐫𝐯𝟑𝟐𝐢 as 𝑪𝑷𝑼_𝗿𝘃𝟯𝟮𝗶>) {
    }

    [𝔯𝔳64𝔦]
    fn slow_decode_compressed_instruction_rv64i -> (𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐤𝐢𝐧𝐝_𝗿𝘃𝟲𝟰𝗶, 𝐨𝐩𝐞𝐫𝐚𝐧𝐝_𝗿𝘃𝟲𝟰𝗶<𝐚𝐬𝐬𝐦𝐛𝐥𝐞𝐫_𝐫𝐯𝟔𝟒𝐢 as 𝑪𝑷𝑼_𝗿𝘃𝟲𝟰𝗶>){
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
enum 𝐜𝐨𝐦𝐩𝐫𝐞𝐬𝐞𝐝_𝐬𝐭𝐞𝐩 {
  𝔠_𝔞𝔡𝔡𝔦4𝔰𝔭𝔫 = 0,
  𝔠_𝔣𝔩𝔡 = 1, // Used for 𝔠_𝔩𝔮, too.
  𝔠_𝔩𝔴 = 2,
  𝔠_𝔣𝔩𝔴 = 3, // Used for 𝔠_𝔩𝔡, too.
  𝔠_𝔯𝔢𝔰𝔢𝔯𝔳𝔢𝔡 = 4,
  𝔠_𝔣𝔰𝔡 = 5, // Used for 𝔠_𝔰𝔮, too.
  𝔠_𝔰𝔴 = 6,
  𝔠_𝔣𝔰𝔴 = 7, // Used for 𝔠_𝔰𝔡, too.
  // Here we need to decode both immediate (one bit) and parts of 𝔯𝔡1/𝔯𝔰1.
  // We handle negative bit separately.
  𝔠_𝔞𝔡𝔡𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_00 = 8,
  𝔠_𝔞𝔡𝔡𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_01 = 9,
  𝔠_𝔞𝔡𝔡𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_10 = 10,
  𝔠_𝔞𝔡𝔡𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_11 = 11,
  𝔠_𝔞𝔡𝔡𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_00 = 12,
  𝔠_𝔞𝔡𝔡𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_01 = 13,
  𝔠_𝔞𝔡𝔡𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_10 = 14,
  𝔠_𝔞𝔡𝔡𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_11 = 15,
  𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_00 = 16, // Used for 𝔠_𝔧𝔞𝔩, too.
  𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_01 = 17,
  𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_10 = 18,
  𝔠_𝔞𝔡𝔡𝔦𝔴_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_11 = 19,
  𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_00 = 20,
  𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_01 = 21,
  𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_10 = 22,
  𝔠_𝔞𝔡𝔡𝔦𝔴_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_11 = 23,
  𝔠_𝔩𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢 = 24,
  𝔠_𝔩𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢 = 25,
  𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_00 = 26,
  𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_01 = 27,
  𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_10 = 28,
  𝔠_𝔩𝔲𝔦_𝔭𝔬𝔰𝔦𝔱𝔦𝔳𝔢_11 = 29,
  𝔠_𝔩𝔲𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_00 = 30,
  𝔠_𝔩𝔲𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_01 = 31,
  𝔠_𝔩𝔲𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_10 = 32,
  𝔠_𝔩𝔲𝔦_𝔫𝔞𝔤𝔞𝔱𝔦𝔳𝔢_11 = 33,
  // Treating these separately simplifies the logic, although, strictly speaking, is not needed.
  𝔠_𝔰𝔯𝔩𝔦_𝔩𝔬𝔴 = 34,
  𝔠_𝔰𝔯𝔩𝔦_𝔥𝔦𝔤𝔥 = 35,
  𝔠_𝔰𝔯𝔞𝔦_𝔩𝔬𝔴 = 36,
  𝔠_𝔰𝔯𝔞𝔦_𝔥𝔦𝔤𝔥 = 37,
  𝔠_𝔞𝔫𝔡𝔦_𝔩𝔬𝔴 = 38,
  𝔠_𝔞𝔫𝔡𝔦_𝔥𝔦𝔤𝔥 = 39,
  // These instruction needs additional decoding.
  𝔠_𝔞𝔫𝔡_𝔬𝔯_𝔰𝔲𝔟_𝔵𝔬𝔯 = 40,
  𝔠_𝔞𝔡𝔡𝔴_𝔰𝔲𝔟𝔴 = 41,
  𝔠_𝔧 = 42,
  𝔠_𝔟𝔢𝔮𝔷 = 43,
  𝔠_𝔟𝔫𝔢𝔷 = 44,
  𝔠_𝔰𝔩𝔩𝔦_𝔩𝔬𝔴 = 46,
  𝔠_𝔰𝔩𝔩𝔦_𝔥𝔦𝔤𝔥 = 47,
  𝔠_𝔣𝔩𝔡𝔰𝔭_𝔩𝔬𝔴 = 48, // Use for 𝔠_𝔩𝔮𝔰𝔭, too.
  𝔠_𝔣𝔩𝔡𝔰𝔭_𝔥𝔦𝔤𝔥 = 49,
  𝔠_𝔩𝔴𝔰𝔭_𝔩𝔬𝔴 = 50,
  𝔠_𝔩𝔴𝔰𝔭_𝔥𝔦𝔤𝔥 = 51,
  𝔠_𝔣𝔩𝔴𝔰𝔭_𝔩𝔬𝔴 = 52, // Used for 𝔠_𝔩𝔡𝔰𝔭, too.
  𝔠_𝔣𝔩𝔴𝔰𝔭_𝔥𝔦𝔤𝔥 = 53, // Used for 𝔠_𝔩𝔡𝔰𝔭, too.
  𝔠_𝔪𝔳 = 54, // Used for 𝔠_𝔧𝔯, too.
  𝔠_𝔞𝔡𝔡 = 45,  // Used for 𝔠_𝔧𝔞𝔩𝔯 and 𝔠_𝔢𝔟𝔯𝔢𝔞𝔨, too. 
  𝔠_𝔣𝔰𝔡𝔰𝔭 = 55, // Used for 𝔠_𝔰𝔮𝔰𝔭, too.
  𝔠_𝔰𝔴𝔰𝔭 = 56,
  𝔠_𝔣𝔰𝔴𝔰𝔭 = 57, // User for 𝔠_𝔰𝔡𝔴𝔭, too.
  𝔠_𝔲𝔫𝔯𝔢𝔠𝔬𝔤𝔫𝔦𝔷𝔢𝔡 = 58,
}
