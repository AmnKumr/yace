/*
 * Permission is hereby granted, free of charge, to any human obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit humans to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

pub trait 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓 {
    type 𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞;
    type 𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞;
    fn emit_u8(&mut self, value: u8) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞>;
    #[inline(always)]
    fn emit_i8(&mut self, value: i8) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(value as u8)
    }
    #[inline(always)]
    fn emit_u16(&mut self, value: u16) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(value as u8)?;
        self.emit_u8((value >> 8) as u8)
    }
    #[inline(always)]
    fn emit_i16(&mut self, value: i16) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u16(value as u16)
    }
    #[inline(always)]
    fn emit_u32(&mut self, value: u32) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u16(value as u16)?;
        self.emit_u16((value >> 16) as u16)
    }
    #[inline(always)]
    fn emit_i32(&mut self, value: i32) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u32(value as u32)
    }
    #[inline(always)]
    fn emit_u64(&mut self, value: u64) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u32(value as u32)?;
        self.emit_u32((value >> 32) as u32)
    }
    #[inline(always)]
    fn emit_i64(&mut self, value: i64) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u64(value as u64)
    }
    #[cfg(has_i128)]
    #[inline(always)]
    fn emit_u128(&mut self, value: u128) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u64(value as u64)?;
        self.emit_u64((value >> 64) as u64)
    }
    #[cfg(has_i128)]
    #[inline(always)]
    fn emit_u128(&mut self, value: i128) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u128(value as u128)
    }
}

#[allow(non_upper_case_globals)]
pub trait 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<const 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮: usize> : 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓 {
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮]
    ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞>;
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<1> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 1]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<2> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 2]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[1] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u16))
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<3> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 3]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[2] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u16))
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<4> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 4]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[3] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[2] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[1] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u32))
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<5> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 5]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[4] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[3] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[2] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u32))
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<6> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 6]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[1] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u16))?;
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[5] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[4] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[3] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[2] as u32))
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<7> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 7]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[2] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u16))?;
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[6] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[5] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[4] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[3] as u32))
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<8> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 8]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[5] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[4] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[3] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[2] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[1] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<9> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 9]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[5] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[4] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[3] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[2] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<10> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 10]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[1] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u16))?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[9] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[5] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[4] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[3] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[2] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<11> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 11]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[2] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u16))?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[10] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[9] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[5] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[4] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[3] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<12> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 12]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[3] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[2] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[1] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u32))?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[11] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[10] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[9] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[5] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[4] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<13> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 13]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[4] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[3] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[2] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u32))?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[12] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[11] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[10] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[9] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[5] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<14> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 14]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[1] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u16))?;
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[5] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[4] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[3] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[2] as u32))?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[13] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[12] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[11] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[10] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[9] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[6] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<15> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 15]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[2] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u16))?;
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[6] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[5] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[4] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[3] as u32))?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[14] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[13] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[12] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[11] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[10] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[9] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[7] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<16> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[cfg(has_i128)]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 16]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u128(
            ((𝖺𝗋𝗋𝖺𝗒[15] as u128) << 120) | ((𝖺𝗋𝗋𝖺𝗒[14] as u128) << 112) | ((𝖺𝗋𝗋𝖺𝗒[13] as u128) << 104) | ((𝖺𝗋𝗋𝖺𝗒[12] as u128) << 96) |
            ((𝖺𝗋𝗋𝖺𝗒[11] as u128) << 88) | ((𝖺𝗋𝗋𝖺𝗒[10] as u128) << 80) | ((𝖺𝗋𝗋𝖺𝗒[9] as u128) << 72) | ((𝖺𝗋𝗋𝖺𝗒[8] as u128) << 64) |
            ((𝖺𝗋𝗋𝖺𝗒[7] as u128) << 56) | ((𝖺𝗋𝗋𝖺𝗒[6] as u128) << 48) | ((𝖺𝗋𝗋𝖺𝗒[5] as u128) << 40) | ((𝖺𝗋𝗋𝖺𝗒[4] as u128) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[3] as u128) << 24) | ((𝖺𝗋𝗋𝖺𝗒[2] as u128) << 16) | ((𝖺𝗋𝗋𝖺𝗒[1] as u128) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u128)
        )
    }
    #[cfg(not(has_i128))]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 16]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[5] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[4] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[3] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[2] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[1] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u64)
        )?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[15] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[14] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[13] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[12] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[11] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[10] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[9] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[8] as u64)
        )
    }
}

// Note: currently the longest known ₓ86_64 instruction is 𝔵𝔯𝔢𝔩𝔢𝔞𝔰𝔢 𝔩𝔬𝔠𝔨 𝔞𝔡𝔡 %𝔣𝔰:𝔮𝔴𝔬𝔯𝔡 𝔭𝔱𝔯 [1234 + %𝔯8𝔡 + %𝔯9𝔡], 1234 — it's
// 16 bytes long (and thus is rejected by most CPUs).
//
// But there are certain impossible combinations of prefixes/options which are longer.
//
// Thus we need to provide 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<17>..=𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<21>.
impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<17> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[cfg(has_i128)]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 17]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u128(
            ((𝖺𝗋𝗋𝖺𝗒[16] as u128) << 120) | ((𝖺𝗋𝗋𝖺𝗒[15] as u128) << 112) | ((𝖺𝗋𝗋𝖺𝗒[14] as u128) << 104) | ((𝖺𝗋𝗋𝖺𝗒[13] as u128) << 96) |
            ((𝖺𝗋𝗋𝖺𝗒[12] as u128) << 88) | ((𝖺𝗋𝗋𝖺𝗒[11] as u128) << 80) | ((𝖺𝗋𝗋𝖺𝗒[10] as u128) << 72) | ((𝖺𝗋𝗋𝖺𝗒[9] as u128) << 64) |
            ((𝖺𝗋𝗋𝖺𝗒[8] as u128) << 56) | ((𝖺𝗋𝗋𝖺𝗒[7] as u128) << 48) | ((𝖺𝗋𝗋𝖺𝗒[6] as u128) << 40) | ((𝖺𝗋𝗋𝖺𝗒[5] as u128) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[4] as u128) << 24) | ((𝖺𝗋𝗋𝖺𝗒[3] as u128) << 16) | ((𝖺𝗋𝗋𝖺𝗒[2] as u128) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u128)
        )
    }
    #[cfg(not(has_i128))]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 17]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[5] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[4] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[3] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[2] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u64)
        )?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[16] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[15] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[14] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[13] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[12] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[11] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[10] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[9] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<18> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[cfg(has_i128)]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 18]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[1] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u16))?;
        self.emit_u128(
            ((𝖺𝗋𝗋𝖺𝗒[17] as u128) << 120) | ((𝖺𝗋𝗋𝖺𝗒[16] as u128) << 112) | ((𝖺𝗋𝗋𝖺𝗒[15] as u128) << 104) | ((𝖺𝗋𝗋𝖺𝗒[14] as u128) << 96) |
            ((𝖺𝗋𝗋𝖺𝗒[13] as u128) << 88) | ((𝖺𝗋𝗋𝖺𝗒[12] as u128) << 80) | ((𝖺𝗋𝗋𝖺𝗒[11] as u128) << 72) | ((𝖺𝗋𝗋𝖺𝗒[10] as u128) << 64) |
            ((𝖺𝗋𝗋𝖺𝗒[9] as u128) << 56) | ((𝖺𝗋𝗋𝖺𝗒[8] as u128) << 48) | ((𝖺𝗋𝗋𝖺𝗒[7] as u128) << 40) | ((𝖺𝗋𝗋𝖺𝗒[6] as u128) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[5] as u128) << 24) | ((𝖺𝗋𝗋𝖺𝗒[4] as u128) << 16) | ((𝖺𝗋𝗋𝖺𝗒[3] as u128) << 8) | (𝖺𝗋𝗋𝖺𝗒[2] as u128)
        )
    }
    #[cfg(not(has_i128))]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 18]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[1] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u16))?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[9] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[5] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[4] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[3] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[2] as u64)
        )?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[17] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[16] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[15] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[14] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[13] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[12] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[11] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[10] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<19> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[cfg(has_i128)]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 19]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[2] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u16))?;
        self.emit_u128(
            ((𝖺𝗋𝗋𝖺𝗒[18] as u128) << 120) | ((𝖺𝗋𝗋𝖺𝗒[17] as u128) << 112) | ((𝖺𝗋𝗋𝖺𝗒[16] as u128) << 104) | ((𝖺𝗋𝗋𝖺𝗒[15] as u128) << 96) |
            ((𝖺𝗋𝗋𝖺𝗒[14] as u128) << 88) | ((𝖺𝗋𝗋𝖺𝗒[13] as u128) << 80) | ((𝖺𝗋𝗋𝖺𝗒[12] as u128) << 72) | ((𝖺𝗋𝗋𝖺𝗒[11] as u128) << 64) |
            ((𝖺𝗋𝗋𝖺𝗒[10] as u128) << 56) | ((𝖺𝗋𝗋𝖺𝗒[9] as u128) << 48) | ((𝖺𝗋𝗋𝖺𝗒[8] as u128) << 40) | ((𝖺𝗋𝗋𝖺𝗒[7] as u128) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[6] as u128) << 24) | ((𝖺𝗋𝗋𝖺𝗒[5] as u128) << 16) | ((𝖺𝗋𝗋𝖺𝗒[4] as u128) << 8) | (𝖺𝗋𝗋𝖺𝗒[3] as u128)
        )
    }
    #[cfg(not(has_i128))]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 19]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u16(((𝖺𝗋𝗋𝖺𝗒[2] as u16) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u16))?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[10] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[9] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[5] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[4] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[3] as u64)
        )?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[18] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[17] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[16] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[15] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[14] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[13] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[12] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[11] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<20> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[cfg(has_i128)]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 20]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[3] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[2] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[1] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u32))?;
        self.emit_u128(
            ((𝖺𝗋𝗋𝖺𝗒[19] as u128) << 120) | ((𝖺𝗋𝗋𝖺𝗒[18] as u128) << 112) | ((𝖺𝗋𝗋𝖺𝗒[17] as u128) << 104) | ((𝖺𝗋𝗋𝖺𝗒[16] as u128) << 96) |
            ((𝖺𝗋𝗋𝖺𝗒[15] as u128) << 88) | ((𝖺𝗋𝗋𝖺𝗒[14] as u128) << 80) | ((𝖺𝗋𝗋𝖺𝗒[13] as u128) << 72) | ((𝖺𝗋𝗋𝖺𝗒[12] as u128) << 64) |
            ((𝖺𝗋𝗋𝖺𝗒[11] as u128) << 56) | ((𝖺𝗋𝗋𝖺𝗒[10] as u128) << 48) | ((𝖺𝗋𝗋𝖺𝗒[9] as u128) << 40) | ((𝖺𝗋𝗋𝖺𝗒[8] as u128) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[7] as u128) << 24) | ((𝖺𝗋𝗋𝖺𝗒[6] as u128) << 16) | ((𝖺𝗋𝗋𝖺𝗒[5] as u128) << 8) | (𝖺𝗋𝗋𝖺𝗒[4] as u128)
        )
    }
    #[cfg(not(has_i128))]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 20]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[3] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[2] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[1] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[0] as u32))?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[11] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[10] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[9] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[5] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[4] as u64)
        )?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[19] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[18] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[17] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[16] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[15] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[14] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[13] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[12] as u64)
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓> 𝒃𝒚𝒕𝒆_𝒂𝒓𝒓𝒂𝒚_𝒆𝒎𝒊𝒕𝒕𝒆𝒓<21> for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[cfg(has_i128)]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 21]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[4] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[3] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[2] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u32))?;
        self.emit_u128(
            ((𝖺𝗋𝗋𝖺𝗒[20] as u128) << 120) | ((𝖺𝗋𝗋𝖺𝗒[19] as u128) << 112) | ((𝖺𝗋𝗋𝖺𝗒[18] as u128) << 104) | ((𝖺𝗋𝗋𝖺𝗒[17] as u128) << 96) |
            ((𝖺𝗋𝗋𝖺𝗒[16] as u128) << 88) | ((𝖺𝗋𝗋𝖺𝗒[15] as u128) << 80) | ((𝖺𝗋𝗋𝖺𝗒[14] as u128) << 72) | ((𝖺𝗋𝗋𝖺𝗒[13] as u128) << 64) |
            ((𝖺𝗋𝗋𝖺𝗒[12] as u128) << 56) | ((𝖺𝗋𝗋𝖺𝗒[11] as u128) << 48) | ((𝖺𝗋𝗋𝖺𝗒[10] as u128) << 40) | ((𝖺𝗋𝗋𝖺𝗒[9] as u128) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[8] as u128) << 24) | ((𝖺𝗋𝗋𝖺𝗒[7] as u128) << 16) | ((𝖺𝗋𝗋𝖺𝗒[6] as u128) << 8) | (𝖺𝗋𝗋𝖺𝗒[5] as u128)
        )
    }
    #[cfg(not(has_i128))]
    #[inline(always)]
    fn emit_array(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 21]
    ) -> Result<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8(𝖺𝗋𝗋𝖺𝗒[0])?;
        self.emit_u32(((𝖺𝗋𝗋𝖺𝗒[4] as u32) << 24) | ((𝖺𝗋𝗋𝖺𝗒[3] as u32) << 16) | ((𝖺𝗋𝗋𝖺𝗒[2] as u32) << 8) | (𝖺𝗋𝗋𝖺𝗒[1] as u32))?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[12] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[11] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[10] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[9] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[8] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[7] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[6] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[5] as u64)
        )?;
        self.emit_u64(
            ((𝖺𝗋𝗋𝖺𝗒[20] as u64) << 56) | ((𝖺𝗋𝗋𝖺𝗒[19] as u64) << 48) | ((𝖺𝗋𝗋𝖺𝗒[18] as u64) << 40) | ((𝖺𝗋𝗋𝖺𝗒[17] as u64) << 32) |
            ((𝖺𝗋𝗋𝖺𝗒[16] as u64) << 24) | ((𝖺𝗋𝗋𝖺𝗒[15] as u64) << 16) | ((𝖺𝗋𝗋𝖺𝗒[14] as u64) << 8) | (𝖺𝗋𝗋𝖺𝗒[13] as u64)
        )
    }
}

pub trait 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Self::𝐭𝐚𝐫𝐠𝐞𝐭: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

// Immediates are always signed on 𝔵86.
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i8 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i8;
}

impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i16 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i16;
}

impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i32 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i32;
}

impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i64 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i64;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<i16>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    i16,
                    𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒄𝒂𝒍𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<i32>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    <𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮 as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒄𝒂𝒍𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    i32,
                    𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

pub trait 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒄𝒂𝒍𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Self::𝐭𝐚𝐫𝐠𝐞𝐭: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭: Default;
}

// Same as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏 but accumulator (𝔞𝔩, 𝔞𝔵, 𝔢𝔞𝔵, 𝔯𝔞𝔵, but not 𝔞𝔥) is not merged with other registers.
// Note: it's variant of 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏, and not 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅 because of peculiarity of the
// 𝔵86 ISA: all instructions with special accumulator-only encoding (for explicit, not implicit argument!) also have 8ᵇⁱᵗ version.
pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒔𝒆𝒑𝒂𝒓𝒂𝒕𝒆_𝒂𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Self::𝐭𝐚𝐫𝐠𝐞𝐭: From<Self>,
{
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

// Immediates are always signed on 𝔵86.
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒔𝒆𝒑𝒂𝒓𝒂𝒕𝒆_𝒂𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i8 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i8;
}

impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒔𝒆𝒑𝒂𝒓𝒂𝒕𝒆_𝒂𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i16 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i16;
}

impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒔𝒆𝒑𝒂𝒓𝒂𝒕𝒆_𝒂𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i32 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i32;
}

impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒔𝒆𝒑𝒂𝒓𝒂𝒕𝒆_𝒂𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i64 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i64;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒔𝒆𝒑𝒂𝒓𝒂𝒕𝒆_𝒂𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒔𝒆𝒑𝒂𝒓𝒂𝒕𝒆_𝒂𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<i16>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒔𝒆𝒑𝒂𝒓𝒂𝒕𝒆_𝒂𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
          <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭:
              𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭:
              𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          Option<<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                     <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
          Option<<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                     <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          Option<<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                      <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
          Option<<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                      <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                     <<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                      as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                     <<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                      as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                     i16,
                     𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒄𝒂𝒍𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<i32>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒔𝒆𝒑𝒂𝒓𝒂𝒕𝒆_𝒂𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
          <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭:
              𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭:
              𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          Option<<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                     <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
          Option<<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                     <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          Option<<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                      <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
          Option<<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                      <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    <<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                     as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    <<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                     as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    <𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒄𝒂𝒍𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    i32,
                    𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

// In legacy modes this is the same as 𝒈𝒆𝒏𝒆𝒓𝒊𝒄_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅. But in 64ᵇⁱᵗ mode situation is significantly more complex:
// not only there are three separate register clases (𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_8ᵇⁱᵗₗₒ, 𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_8ᵇⁱᵗₕᵢ, and other 8ᵇⁱᵗ registers), this
// also affects other arguments!  E.g. address must use 𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_XXᵇⁱᵗₙₒᵣₑₓ for base and 𝐚𝐝𝐝𝐫𝐞𝐬𝐬_𝐢𝐧𝐝𝐞𝐱_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_XXᵇⁱᵗₙₒᵣₑₓ
// for index if other argument is of 𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_8ᵇⁱᵗₕᵢ class.
//
// Thankfully most modern instructions (like 3-operand 𝔞𝔡𝔠𝔵 or 𝔟𝔢𝔵𝔱𝔯 instructions) don't have an 8ᵇⁱᵗ variants.
//
// Note: for instructions which 𝗱𝗼 have an 8-bit variants (like 𝔞𝔡𝔡 or 𝔰𝔲𝔟) we have to use that argument even if we are not
// dealing with 8ᵇⁱᵗ instructions.  This is because 𝒂𝒅𝒅_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏𝒔 and 𝒂𝒅𝒅_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏 traits are used
// before we know if we are dealing with 8ᵇⁱᵗ arguments or not.

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Self::𝐭𝐚𝐫𝐠𝐞𝐭: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

// Immediates are always signed on 𝔵86.
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i8 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i8;
}

impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i16 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i16;
}

impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i32 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i32;
}

impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i64 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i64;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<i16>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
          <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭:
              𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭:
              𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          Option<<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                     <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
          Option<<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                     <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          Option<<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                      <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
          Option<<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                      <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                     <<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                      as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                     <<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                      as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                     i16,
                     𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒄𝒂𝒍𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<i32>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
          <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭:
              𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭:
              𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          Option<<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                     <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
          Option<<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                     <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>,
          Option<<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                      <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
          Option<<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                  as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
                                      <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭>:
              From<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    <<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                     as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    <<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭
                     as 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    <𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒄𝒂𝒍𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                    i32,
                    𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒄𝒂𝒍𝒆_𝒐𝒇_8ᵇⁱᵗ_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Self::𝐭𝐚𝐫𝐠𝐞𝐭: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭: Default;
}

// Additional step for the ᵣₑₓ/ₙₒᵣₑₓ types handling: we want to provide two types: ₙₒᵣₑₓ compliant and ᵣₑₓ-requiring.
// If base is ₙₒᵣₑₓ but index is ᵣₑₓ then we make base ᵣₑₓ. Same with index.
pub trait 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒃𝒂𝒔𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>: Sized
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒓𝒆𝒙_𝒆𝒙𝒑𝒂𝒏𝒅_𝒊𝒏𝒅𝒆𝒙<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>: Sized
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

// Shift counter may be 𝔠𝔩 or 8ᵇⁱᵗ immediate, there are no other options.
pub trait 𝒄𝒐𝒖𝒏𝒕𝒆𝒓_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Self::𝐭𝐚𝐫𝐠𝐞𝐭: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒄𝒐𝒖𝒏𝒕𝒆𝒓_𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i8 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i8;
}

// String source may be 𝔡𝔰:[𝔰𝔦], 𝔡𝔰:[𝔢𝔰𝔦], or [𝔯𝔰𝔦] and 𝔡𝔰 can be replaced.
// String destination may be 𝔢𝔰:[𝔡𝔦], 𝔢𝔰:[𝔢𝔡𝔦], or [𝔯𝔡𝔦] and segment can onle be 𝔢𝔰.
// To handle that we have separate traits.
pub trait 𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒔𝒕𝒓𝒊𝒏𝒈_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Self::𝐭𝐚𝐫𝐠𝐞𝐭: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒔𝒐𝒖𝒓𝒄𝒆_𝒔𝒕𝒓𝒊𝒏𝒈_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Self::𝐭𝐚𝐫𝐠𝐞𝐭: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒔𝒕𝒓𝒊𝒏𝒈_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒔𝒐𝒖𝒓𝒄𝒆_𝒔𝒕𝒓𝒊𝒏𝒈_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

// 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔 includes original bitness (as 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ/32ᵇⁱᵗ/64ᵇⁱᵗ field) and index (𝔡𝔦/𝔢𝔡𝔦/𝔯𝔡𝔦 or 𝔰𝔦/𝔢𝔰𝔦/𝔯𝔰𝔦)
// But we are converting it to 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔/𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔 which only includes index.
// This means that there are risk of merging, e.g. 𝔞𝔡𝔡𝔯𝔢𝔰𝔰_16ᵇⁱᵗ and 𝔯𝔰𝔦 which shouldn't be possible.
// Separation of 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏 in three traits ensures that we wouldn't accept that code.
#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_16ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒔𝒕𝒓𝒊𝒏𝒈_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_16ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                               <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_16ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                               𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_16ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒔𝒐𝒖𝒓𝒄𝒆_𝒔𝒕𝒓𝒊𝒏𝒈_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_16ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                          <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_16ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                          𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_32ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒔𝒕𝒓𝒊𝒏𝒈_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_32ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                               <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_32ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                               𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_32ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒔𝒐𝒖𝒓𝒄𝒆_𝒔𝒕𝒓𝒊𝒏𝒈_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_32ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                          <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_32ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                          𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_64ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒔𝒕𝒓𝒊𝒏𝒈_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_64ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                               <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_64ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                               𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_64ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒔𝒐𝒖𝒓𝒄𝒆_𝒔𝒕𝒓𝒊𝒏𝒈_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_64ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 =
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                          <𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_64ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                          𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized + 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒔𝒆𝒈𝒎𝒆𝒏𝒕
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_16ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized + 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒊𝒏𝒅𝒆𝒙
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_16ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized + 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒊𝒏𝒅𝒆𝒙
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_32ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized + 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒊𝒏𝒅𝒆𝒙
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_32ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized + 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒊𝒏𝒅𝒆𝒙
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_64ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized + 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒊𝒏𝒅𝒆𝒙
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒊𝒏𝒅𝒆𝒙_64ᵇⁱᵗ_𝒐𝒇_𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized + 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒊𝒏𝒅𝒆𝒙
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

// Instruction 𝔵𝔩𝔞𝔱 accepts unique type of operand with base in 𝔟𝔵, possible segment selection and no index or desplacement.
pub trait 𝒙𝒍𝒂𝒕_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Self::𝐭𝐚𝐫𝐠𝐞𝐭: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮, 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒙𝒍𝒂𝒕_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

// 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔 includes original bitness (as 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ/32ᵇⁱᵗ/64ᵇⁱᵗ field) and base (𝔟𝔵/𝔢𝔟𝔵/𝔯𝔟𝔵).
// But we are converting it to 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔 which only includes base.
// This means that there are risk of merging, e.g. 𝔞𝔡𝔡𝔯𝔢𝔰𝔰_16ᵇⁱᵗ and 𝔯𝔟𝔵 which shouldn't be possible.
// Separation of 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏 in three traits ensures that we wouldn't accept that code.
#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_16ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒙𝒍𝒂𝒕_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_16ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                           <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as  𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_16ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                           𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮:  𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_32ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒙𝒍𝒂𝒕_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_32ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                           <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as  𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_32ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                           𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

#[allow(non_upper_case_globals)]
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮,
     𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮:  𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_64ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>,
     const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒙𝒍𝒂𝒕_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>
    for 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    where Option<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
          Option<<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_64ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭>: From<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮> {
    #[allow(clippy::type_complexity)]
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 as 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                           <𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 as  𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_64ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>>::𝐭𝐚𝐫𝐠𝐞𝐭,
                                           𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_16ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized + 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒃𝒂𝒔𝒆
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_32ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized + 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒃𝒂𝒔𝒆
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

pub trait 𝒂𝒔𝒔𝒆𝒎𝒃𝒍𝒆𝒓_𝒃𝒂𝒔𝒆_64ᵇⁱᵗ_𝒐𝒇_𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized + 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒃𝒂𝒔𝒆
where Option<Self::𝐭𝐚𝐫𝐠𝐞𝐭>: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

// Instructions 𝔦𝔫/𝔦𝔫𝔰/𝔬𝔲𝔱/𝔬𝔲𝔱𝔰 accepts port number as 8ᵇⁱᵗ immediate or 16ᵇⁱᵗ 𝔡𝔵 register, there are no other choices.
pub trait 𝒊𝒐_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮>: Sized
where Self::𝐭𝐚𝐫𝐠𝐞𝐭: From<Self> {
    type 𝐭𝐚𝐫𝐠𝐞𝐭;
}

// Immediates are always signed on 𝔵86.
impl<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> 𝒊𝒐_𝒐𝒑𝒆𝒓𝒂𝒏𝒅<𝓪𝓼𝓼𝓮𝓶𝓫𝓵𝓮𝓻_𝓽𝔂𝓹𝓮> for i8 {
    type 𝐭𝐚𝐫𝐠𝐞𝐭 = i8;
}

// Marker trait to prevenct conflict for Option<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>: should it be Some(𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞{}) or None?
pub trait 𝒐𝒑𝒕𝒊𝒐𝒏_𝒇𝒓𝒐𝒎_𝒖𝒏𝒇𝒊𝒍𝒍𝒆𝒅_𝒇𝒍𝒖𝒆𝒏𝒕_𝒗𝒂𝒍𝒖𝒆 {}

// Address includes some values which are optional and can be unfilled. We use empty type to mark these.
// Note: we can not use just an empty tuple because then we couldn't define From trait for it.
// Note2: scale and displacement must be obtainable from 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞.  Integer types are obtainable automatically.
pub struct 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {}

// All assembler support two addresses: 16ᵇⁱᵗ and 32ᵇⁱᵗ in legacy mode or 32ᵇⁱᵗ and 64ᵇⁱᵗ in ₓ86_64 mode.
// We provide different address constants for these three modes — that way there are no ambiguity even if simple 𝔞𝔡𝔡𝔯𝔢𝔰𝔰 [0] is used.
pub struct 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ {} // We don't really need that because of 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086 vs 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86 difference. Maybe remove?
pub struct 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ {}
pub struct 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ {}

// Address type is just a combination of arguments and it's mostly used to simplify interface. There are few address types:
//   1. Absolute address — segment plus 16ᵇⁱᵗ/32ᵇⁱᵗ/64ᵇⁱᵗ offset. Only used in 𝔪𝔬𝔳 instruction and is quite similar to “normal”
//      address in legacy modes. In 64ᵇⁱᵗ x86-64 mode it's different, though, since it's the only one with support for 64ᵇⁱᵗ offset.
//      We can not just use similar trick to how we handle 𝔠𝔪𝔭𝔰/𝔦𝔫𝔰/𝔩𝔬𝔡𝔰/𝔪𝔬𝔳𝔰/𝔬𝔲𝔱𝔰/𝔰𝔠𝔞𝔰/𝔰𝔱𝔬𝔰/𝔵𝔩𝔞𝔱 because 𝔪𝔬𝔳 supports both addresses:
//          mov(𝔢𝔞𝔵, 𝔞𝔟𝔰𝔬𝔩𝔲𝔱𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰.with_offset(0)) would emit 0xa1, 0x00, 0x00, 0x00, 0x00
//          mov(𝔢𝔞𝔵, 𝔞𝔡𝔡𝔯𝔢𝔰𝔰_32ᵇⁱᵗ.with_disp(0)) would emit 0x8b, 0x05, 0x00, 0x00, 0x00, 0x00
//   2. Legacy 16ᵇⁱᵗ 8086 address — segment, base, index and 16ᵇⁱᵗ displacement. Supported in “legacy” 16ᵇⁱᵗ/32ᵇⁱᵗ assemblers.
//      All optional except displacemet (which can be zero).
//   3. Modern 32ᵇⁱᵗ/64ᵇⁱᵗ address — segment, base, index, scale and 32ᵇⁱᵗ displacement.
//      All optional except for scale (which can be 1 and that's default) and displacement (which can be zero).
//   4. Gather address — segment, base, index, scale and 32ᵇⁱᵗ displacement.
//      Similar to previous one, but index is vector register and, more importantly, it's not optional.
//
// Also some instructions only support limited addresses:
//   𝔢𝔦𝔭/𝔯𝔦𝔭 based address in ₓ86_64 mode — segment and displacement from 𝔢𝔦𝔭/𝔯𝔦𝔭
//
//   𝔠𝔪𝔭𝔰/𝔦𝔫𝔰/𝔪𝔬𝔳𝔰/𝔰𝔠𝔞𝔰 — destination: only segment and index which must be 𝔡𝔦/𝔡𝔰𝔦/𝔡𝔰𝔦 (depending on address size)
//   𝔠𝔪𝔭𝔰/𝔩𝔬𝔡𝔰/𝔪𝔬𝔳𝔰/𝔬𝔲𝔱𝔰/𝔰𝔱𝔬𝔰 — source: only segment and index which must be 𝔰𝔦/𝔢𝔰𝔦/𝔯𝔰𝔦 (depending on address size)
//   𝔵𝔩𝔞𝔱 — only segment and base which must be 𝔟𝔵/𝔢𝔟𝔵/𝔯𝔟𝔵 (depending on address size)
//  
// These have their own types used in the implementation of instructions, but use standard 𝔞𝔡𝔡𝔯𝔢𝔰𝔰_16ᵇⁱᵗ/𝔞𝔡𝔡𝔯𝔢𝔰𝔰_32ᵇⁱᵗ/𝔞𝔡𝔡𝔯𝔢𝔰𝔰_64ᵇⁱᵗ
// fluent constants and machinery.
#[allow(non_upper_case_globals)]
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮: Default, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: Option<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    pub 𝗈𝖿𝖿𝗌𝖾𝗍: 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮,
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮: Default> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 0>
{
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_byte_ptr(
        self,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 1> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 1> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗈𝖿𝖿𝗌𝖾𝗍: self.𝗈𝖿𝖿𝗌𝖾𝗍}
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_word_ptr(
        self,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 2> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 2> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗈𝖿𝖿𝗌𝖾𝗍: self.𝗈𝖿𝖿𝗌𝖾𝗍}
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_dword_ptr(
        self,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 4> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 4> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗈𝖿𝖿𝗌𝖾𝗍: self.𝗈𝖿𝖿𝗌𝖾𝗍}
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_qword_ptr(
        self,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 8> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 8> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗈𝖿𝖿𝗌𝖾𝗍: self.𝗈𝖿𝖿𝗌𝖾𝗍}
    }
    // Generic memory region. Mostly for completeness because all instructions which use arbitrarily sized regions don't need that
    // for disambigution.
    #[allow(clippy::wrong_self_convention)]
    #[allow(non_upper_case_globals)]
    #[inline(always)]
    pub fn to_sized_ptr<const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
        self,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗈𝖿𝖿𝗌𝖾𝗍: self.𝗈𝖿𝖿𝗌𝖾𝗍}
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮: Default,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮: Into<𝓽𝓪𝓻𝓰𝓮𝓽_𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮>,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    > From<𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>>
for 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_ₓ86_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝗈𝖿𝖿𝗌𝖾𝗍: new_address.𝗈𝖿𝖿𝗌𝖾𝗍.into(),
        }
    }
}

#[allow(non_upper_case_globals)]
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: core::marker::PhantomData<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>, 
    pub 𝗂𝗇𝖽𝖾𝗑: core::marker::PhantomData<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 0>
{
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_byte_ptr(
        self,
    ) -> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 1> {
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 1> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑}
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_word_ptr(
        self,
    ) -> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 2> {
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 2> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑}
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_dword_ptr(
        self,
    ) -> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 4> {
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 4> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑}
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_qword_ptr(
        self,
    ) -> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 8> {
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 8> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑}
    }
    // Generic memory region. Mostly for completeness because all instructions which use arbitrarily sized regions don't need that
    // for disambigution.
    #[allow(clippy::wrong_self_convention)]
    #[allow(non_upper_case_globals)]
    #[inline(always)]
    pub fn to_sized_ptr<const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
        self,
    ) -> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑}
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒔𝒆𝒈𝒎𝒆𝒏𝒕,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒊𝒏𝒅𝒆𝒙,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    > From<𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>>
for 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        _: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: core::marker::PhantomData,
            𝗂𝗇𝖽𝖾𝗑: core::marker::PhantomData,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒔𝒆𝒈𝒎𝒆𝒏𝒕,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒊𝒏𝒅𝒆𝒙,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    > From<𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>>
for 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        _: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: core::marker::PhantomData,
            𝗂𝗇𝖽𝖾𝗑: core::marker::PhantomData,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒔𝒆𝒈𝒎𝒆𝒏𝒕,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒊𝒏𝒅𝒆𝒙,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    > From<𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>>
for 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        _: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: core::marker::PhantomData,
            𝗂𝗇𝖽𝖾𝗑: core::marker::PhantomData,
        }
    }
}

pub trait 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒔𝒆𝒈𝒎𝒆𝒏𝒕 {}
// If you don't specify segment 𝔢𝔰 is used automatically. Doesn't have to be specified and in 64ᵇⁱᵗ x86-64 mode can not be specified.
impl 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒔𝒆𝒈𝒎𝒆𝒏𝒕 for 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {}
pub trait 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒅𝒆𝒔𝒕𝒊𝒏𝒂𝒕𝒊𝒐𝒏_𝒊𝒏𝒅𝒆𝒙 {}

#[allow(non_upper_case_globals)]
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: Option<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    pub 𝗂𝗇𝖽𝖾𝗑: core::marker::PhantomData<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 0>
{
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_byte_ptr(
        self,
    ) -> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 1> {
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 1> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑}
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_word_ptr(
        self,
    ) -> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 2> {
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 2> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑}
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_dword_ptr(
        self,
    ) -> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 4> {
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 4> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑}
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_qword_ptr(
        self,
    ) -> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 8> {
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 8> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑}
    }
    // Generic memory region. Mostly for completeness because all instructions which use arbitrarily sized regions don't need that
    // for disambigution.
    #[allow(clippy::wrong_self_convention)]
    #[allow(non_upper_case_globals)]
    #[inline(always)]
    pub fn to_sized_ptr<const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
        self,
    ) -> 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑}
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒊𝒏𝒅𝒆𝒙,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    > From<𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>>
for 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝗂𝗇𝖽𝖾𝗑: core::marker::PhantomData,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒊𝒏𝒅𝒆𝒙,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    > From<𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>>
for 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝗂𝗇𝖽𝖾𝗑: core::marker::PhantomData,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒊𝒏𝒅𝒆𝒙,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    > From<𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>>
for 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝗂𝗇𝖽𝖾𝗑: core::marker::PhantomData,
        }
    }
}

pub trait 𝒔𝒕𝒓𝒊𝒏𝒈_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒔𝒐𝒖𝒓𝒄𝒆_𝒊𝒏𝒅𝒆𝒙 {}

#[allow(non_upper_case_globals)]
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: Option<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    pub 𝖻𝖺𝗌𝖾: core::marker::PhantomData<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮> 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 0>
{
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_byte_ptr(
        self,
    ) -> 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 1> {
        𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 1> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾}
    }
    // Generic memory region. Mostly for completeness because all instructions which use arbitrarily sized regions don't need that
    // for disambigution.
    #[allow(clippy::wrong_self_convention)]
    #[allow(non_upper_case_globals)]
    #[inline(always)]
    pub fn to_sized_ptr<const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
        self,
    ) -> 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾}
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒃𝒂𝒔𝒆,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    > From<𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>>
for 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝖻𝖺𝗌𝖾: core::marker::PhantomData,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒃𝒂𝒔𝒆,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    > From<𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>>
for 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝖻𝖺𝗌𝖾: core::marker::PhantomData,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒃𝒂𝒔𝒆,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    > From<𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>>
for 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝖻𝖺𝗌𝖾: core::marker::PhantomData,
        }
    }
}

pub trait 𝒙𝒍𝒂𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏_𝒃𝒂𝒔𝒆 {}

#[allow(non_upper_case_globals)]
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: Option<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    pub 𝖻𝖺𝗌𝖾: Option<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    pub 𝗂𝗇𝖽𝖾𝗑: Option<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
    pub 𝖽𝗂𝗌𝗉: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default>
    𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 0>
{
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_byte_ptr(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 1> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 1> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_word_ptr(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 2> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 2> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_dword_ptr(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 4> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 4> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_qword_ptr(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 8> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 8> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    // We couldn't distingush far pointer from near pointer by size since 16ᵇⁱᵗ far pointer have the same size as 32ᵇⁱᵗ near pointer
    // and they both can be used in 16ᵇⁱᵗ and 32ᵇⁱᵗ modes.  Use negative sizes instead.
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_far_ptr16(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -4isize as usize }> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -4isize as usize }> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_far_ptr32(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -6isize as usize }> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -6isize as usize }> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    // Generic memory region. Mostly for completeness because all instructions which use arbitrarily sized regions don't need that
    // for disambigution.
    #[allow(clippy::wrong_self_convention)]
    #[allow(non_upper_case_globals)]
    #[inline(always)]
    pub fn to_sized_ptr<const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    > From<𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>>
for 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝖻𝖺𝗌𝖾: new_address.𝖻𝖺𝗌𝖾.into(),
            𝗂𝗇𝖽𝖾𝗑: new_address.𝗂𝗇𝖽𝖾𝗑.into(),
            𝖽𝗂𝗌𝗉: new_address.𝖽𝗂𝗌𝗉.into(),
        }
    }
}

#[allow(non_upper_case_globals)]
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: Option<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    pub 𝖻𝖺𝗌𝖾: Option<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    pub 𝗂𝗇𝖽𝖾𝗑: Option<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
    pub 𝗌𝖼𝖺𝗅𝖾: 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
    pub 𝖽𝗂𝗌𝗉: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default>
    𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 0>
{
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_byte_ptr(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 1> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 1> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_word_ptr(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 2> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 2> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_dword_ptr(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 4> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 4> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_qword_ptr(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 8> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 8> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    // We couldn't distingush far pointer from near pointer by size since 16ᵇⁱᵗ far pointer have the same size as 32ᵇⁱᵗ near pointer
    // and they both can be used in 16ᵇⁱᵗ and 32ᵇⁱᵗ modes.  Use negative sizes instead.
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_far_ptr16(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -4isize as usize }> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -4isize as usize }> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    pub fn to_far_ptr32(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -6isize as usize }> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -6isize as usize }> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_far_ptr64(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -10isize as usize }> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -10isize as usize }> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    // Generic memory region. Mostly for completeness because all instructions which use arbitrarily sized regions don't need that
    // for disambigution.
    #[allow(clippy::wrong_self_convention)]
    #[allow(non_upper_case_globals)]
    #[inline(always)]
    pub fn to_sized_ptr<const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
        self,
    ) -> 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Into<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮>,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    >
    From<
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
            𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮,
        >,
    >
    for 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
        𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮,
    >
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
            𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮,
        >,
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝖻𝖺𝗌𝖾: new_address.𝖻𝖺𝗌𝖾.into(),
            𝗂𝗇𝖽𝖾𝗑: new_address.𝗂𝗇𝖽𝖾𝗑.into(),
            𝗌𝖼𝖺𝗅𝖾: new_address.𝗌𝖼𝖺𝗅𝖾.into(),
            𝖽𝗂𝗌𝗉: new_address.𝖽𝗂𝗌𝗉.into(),
        }
    }
}

#[allow(non_upper_case_globals)]
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒈𝒂𝒕𝒉𝒆𝒓_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: Option<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    pub 𝖻𝖺𝗌𝖾: Option<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    pub 𝗂𝗇𝖽𝖾𝗑: 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
    pub 𝗌𝖼𝖺𝗅𝖾: 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
    pub 𝖽𝗂𝗌𝗉: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
}

#[allow(non_upper_case_globals)]
impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Into<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮>,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>,
        const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize,
    >
    From<
        𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
            𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮,
        >,
    >
    for 𝒈𝒂𝒕𝒉𝒆𝒓_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
        𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮,
    >
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
            𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮,
        >,
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝖻𝖺𝗌𝖾: new_address.𝖻𝖺𝗌𝖾.into(),
            𝗂𝗇𝖽𝖾𝗑: new_address.𝗂𝗇𝖽𝖾𝗑.into(),
            𝗌𝖼𝖺𝗅𝖾: new_address.𝗌𝖼𝖺𝗅𝖾.into(),
            𝖽𝗂𝗌𝗉: new_address.𝖽𝗂𝗌𝗉.into(),
        }
    }
}

#[allow(non_upper_case_globals)]
pub const 𝔞𝔟𝔰𝔬𝔩𝔲𝔱𝔢_𝔞𝔡𝔡𝔯𝔢𝔰𝔰: 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 0> = 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔 {
    𝗌𝖾𝗀𝗆𝖾𝗇𝗍: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {}, 𝗈𝖿𝖿𝗌𝖾𝗍: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
};

#[allow(non_upper_case_globals)]
pub const 𝔞𝔡𝔡𝔯𝔢𝔰𝔰_16ᵇⁱᵗ: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    0,
> = 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086 {
    𝗌𝖾𝗀𝗆𝖾𝗇𝗍: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
    𝖻𝖺𝗌𝖾: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ {},
    𝗂𝗇𝖽𝖾𝗑: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ {},
    𝖽𝗂𝗌𝗉: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
};

#[allow(non_upper_case_globals)]
pub const 𝔞𝔡𝔡𝔯𝔢𝔰𝔰_32ᵇⁱᵗ: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    0,
> = 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86 {
    𝗌𝖾𝗀𝗆𝖾𝗇𝗍: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
    𝖻𝖺𝗌𝖾: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ {},
    𝗂𝗇𝖽𝖾𝗑: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ {},
    𝗌𝖼𝖺𝗅𝖾: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
    𝖽𝗂𝗌𝗉: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
};

#[allow(non_upper_case_globals)]
pub const 𝔞𝔡𝔡𝔯𝔢𝔰𝔰_64ᵇⁱᵗ: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    0,
> = 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86 {
    𝗌𝖾𝗀𝗆𝖾𝗇𝗍: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
    𝖻𝖺𝗌𝖾: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ {},
    𝗂𝗇𝖽𝖾𝗑: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ {},
    𝗌𝖼𝖺𝗅𝖾: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
    𝖽𝗂𝗌𝗉: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
};

// Fluent interface requires the ability to find out type from arguments: Rust doesn't try to do complex pruning when you have
// something like 𝔞𝔡𝔡𝔯𝔢𝔰𝔰.with_base(…).with_index(…).with_disp(…).
//
// Collect all arguments into 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_{8086,ₓ86} instead and then provide conversions into proper addess.
#[allow(non_upper_case_globals)]
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
    pub 𝗈𝖿𝖿𝗌𝖾𝗍: 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮,
}

#[allow(non_upper_case_globals)]
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
    pub 𝖻𝖺𝗌𝖾: 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
    pub 𝗂𝗇𝖽𝖾𝗑: 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
    pub 𝖽𝗂𝗌𝗉: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
}

#[allow(non_upper_case_globals)]
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
    pub 𝖻𝖺𝗌𝖾: 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
    pub 𝗂𝗇𝖽𝖾𝗑: 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
    pub 𝗌𝖼𝖺𝗅𝖾: 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
    pub 𝖽𝗂𝗌𝗉: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
}

// Note: 𝒈𝒂𝒕𝒉𝒆𝒓_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔 have the same structure as 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86 but index is not optioal.
// You have to use .with_index or code wouldn't compile.
#[allow(non_upper_case_globals)]
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
    pub 𝖻𝖺𝗌𝖾: 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
    pub 𝗂𝗇𝖽𝖾𝗑: 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
    pub 𝗌𝖼𝖺𝗅𝖾: 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
    pub 𝖽𝗂𝗌𝗉: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
}

#[allow(non_upper_case_globals)]
impl<𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
{
    #[inline(always)]
    pub fn with_segment<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>(
        self,
        new_segment: 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_segment,
            𝗈𝖿𝖿𝗌𝖾𝗍: self.𝗈𝖿𝖿𝗌𝖾𝗍,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_offset<𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮>(
        self,
        new_offset: 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝗈𝖿𝖿𝗌𝖾𝗍: new_offset,
        }
    }
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮>
    𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 0> {
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_byte_ptr(
        self,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 1> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 1> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝗈𝖿𝖿𝗌𝖾𝗍: self.𝗈𝖿𝖿𝗌𝖾𝗍,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_word_ptr(
        self,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 2> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 2> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝗈𝖿𝖿𝗌𝖾𝗍: self.𝗈𝖿𝖿𝗌𝖾𝗍,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_dword_ptr(
        self,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 4> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 4> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝗈𝖿𝖿𝗌𝖾𝗍: self.𝗈𝖿𝖿𝗌𝖾𝗍,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_qword_ptr(
        self,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 8> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 8> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝗈𝖿𝖿𝗌𝖾𝗍: self.𝗈𝖿𝖿𝗌𝖾𝗍,
        }
    }
    // Generic memory region. Mostly for completeness because all instructions which use arbitrarily sized regions don't need that
    // for disambigution.
    #[allow(clippy::wrong_self_convention)]
    #[allow(non_upper_case_globals)]
    #[inline(always)]
    pub fn to_sized_ptr<const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
        self,
    ) -> 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓸𝓯𝓯𝓼𝓮𝓽_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝗈𝖿𝖿𝗌𝖾𝗍: self.𝗈𝖿𝖿𝗌𝖾𝗍,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>
{
    #[inline(always)]
    pub fn with_segment<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>(
        self,
        new_segment: 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_segment,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_base<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>(
        self,
        new_base: 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: new_base,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_index<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>(
        self,
        new_index: 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: new_index,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_disp<𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>(
        self,
        new_disp: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: new_disp,
        }
    }
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 0> {
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_byte_ptr(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 1> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 1> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_word_ptr(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 2> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 2> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_dword_ptr(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 4> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 4> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_qword_ptr(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 8> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 8> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    // We couldn't distingush far pointer from near pointer by size since 16ᵇⁱᵗ far pointer have the same size as 32ᵇⁱᵗ near pointer
    // and they both can be used in 16ᵇⁱᵗ and 32ᵇⁱᵗ modes.  Use negative sizes instead.
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_far_ptr16(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -4isize as usize }> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -4isize as usize }> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_far_ptr32(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -6isize as usize }> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -6isize as usize }> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
    // Generic memory region. Mostly for completeness because all instructions which use arbitrarily sized regions don't need that
    // for disambigution.
    #[allow(clippy::wrong_self_convention)]
    #[allow(non_upper_case_globals)]
    #[inline(always)]
    pub fn to_sized_ptr<const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_segment<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>(
        self,
        new_segment: 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_segment,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_base<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>(
        self,
        new_base: 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: new_base,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_base<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>(
        self,
        new_base: 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: new_base,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_index<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>(
        self,
        new_index: 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: new_index,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_index<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>(
        self,
        new_index: 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: new_index,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_scale<𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮>(
        self,
        new_scale: 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: new_scale,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_disp<𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>(
        self,
        new_disp: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: new_disp,
        }
    }
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 0>
{
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_byte_ptr(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 1> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 1> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_word_ptr(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 2> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 2> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_dword_ptr(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 4> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 4> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_qword_ptr(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 8> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 8> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    // We couldn't distingush far pointer from near pointer by size since 16ᵇⁱᵗ far pointer have the same size as 32ᵇⁱᵗ near pointer
    // and they both can be used in 16ᵇⁱᵗ and 32ᵇⁱᵗ modes.  Use negative sizes instead.
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_far_ptr16(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -4isize as usize }> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -4isize as usize }> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_far_ptr32(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -6isize as usize }> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -6isize as usize }> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    #[allow(clippy::wrong_self_convention)]
    #[inline(always)]
    pub fn to_far_ptr64(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -10isize as usize }> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, { -10isize as usize }> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
    // Generic memory region. Mostly for completeness because all instructions which use arbitrarily sized regions don't need that
    // for disambigution.
    #[allow(clippy::wrong_self_convention)]
    #[allow(non_upper_case_globals)]
    #[inline(always)]
    pub fn to_sized_ptr<const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
        self,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮 > {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
        𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
        𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
        𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
        𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮,
    >
{
    #[inline(always)]
    pub fn with_segment<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>(
        self,
        new_segment: 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
    ) -> 𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_segment,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_base<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>(
        self,
        new_base: 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
    ) -> 𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: new_base,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_base<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>(
        self,
        new_base: 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
    ) -> 𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: new_base,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_index<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>(
        self,
        new_index: 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
    ) -> 𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: new_index,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_scale<𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮>(
        self,
        new_scale: 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
    ) -> 𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: new_scale,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

#[allow(non_upper_case_globals)]
impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>
    𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
    #[inline(always)]
    pub fn with_disp<𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>(
        self,
        new_disp: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
    ) -> 𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
        𝒈𝒂𝒕𝒉𝒆𝒓_𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: new_disp,
        }
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖎𝖓𝖙𝖊𝖌𝖊𝖗_𝖋𝖗𝖔𝖒 {
    ($($𝓲𝓷𝓽_𝓽𝔂𝓹𝓮_𝓷𝓪𝓶𝓮:ident),*) => {
        $(
            impl From<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞> for $𝓲𝓷𝓽_𝓽𝔂𝓹𝓮_𝓷𝓪𝓶𝓮 {
                #[inline(always)]
                fn from(_: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞) -> $𝓲𝓷𝓽_𝓽𝔂𝓹𝓮_𝓷𝓪𝓶𝓮 {
                    0
                }
            }
         )*
    }
}

𝖉𝖊𝖋𝖎𝖓𝖊_𝖎𝖓𝖙𝖊𝖌𝖊𝖗_𝖋𝖗𝖔𝖒!(i8, u8, i16, u16, i32, u32, i64, u64, isize, usize);

#[cfg(has_i128)]
𝖉𝖊𝖋𝖎𝖓𝖊_𝖎𝖓𝖙𝖊𝖌𝖊𝖗_𝖋𝖗𝖔𝖒!(i128, u128);

impl<𝓲𝓷𝓽_𝓽𝔂𝓹𝓮> From<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞> for core::num::Wrapping<𝓲𝓷𝓽_𝓽𝔂𝓹𝓮>
where 𝓲𝓷𝓽_𝓽𝔂𝓹𝓮: From<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>
{
    #[inline(always)]
    fn from(value: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞) -> Self {
        Self(value.into())
    }
}

// Any 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 type can be converted into the appropriate Option (and will end up as None, of course).
impl<𝓪𝓻𝓫𝓲𝓽𝓻𝓪𝓻𝔂_𝓽𝔂𝓹𝓮: 𝒐𝒑𝒕𝒊𝒐𝒏_𝒇𝒓𝒐𝒎_𝒖𝒏𝒇𝒊𝒍𝒍𝒆𝒅_𝒇𝒍𝒖𝒆𝒏𝒕_𝒗𝒂𝒍𝒖𝒆> From<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞> for Option<𝓪𝓻𝓫𝓲𝓽𝓻𝓪𝓻𝔂_𝓽𝔂𝓹𝓮> {
    #[inline(always)]
    fn from(_: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞) -> Self {
        None
    }
}

impl<𝓪𝓻𝓫𝓲𝓽𝓻𝓪𝓻𝔂_𝓽𝔂𝓹𝓮: 𝒐𝒑𝒕𝒊𝒐𝒏_𝒇𝒓𝒐𝒎_𝒖𝒏𝒇𝒊𝒍𝒍𝒆𝒅_𝒇𝒍𝒖𝒆𝒏𝒕_𝒗𝒂𝒍𝒖𝒆> From<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ> for Option<𝓪𝓻𝓫𝓲𝓽𝓻𝓪𝓻𝔂_𝓽𝔂𝓹𝓮> {
    #[inline(always)]
    fn from(_: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_16ᵇⁱᵗ) -> Self {
        None
    }
}

impl<𝓪𝓻𝓫𝓲𝓽𝓻𝓪𝓻𝔂_𝓽𝔂𝓹𝓮: 𝒐𝒑𝒕𝒊𝒐𝒏_𝒇𝒓𝒐𝒎_𝒖𝒏𝒇𝒊𝒍𝒍𝒆𝒅_𝒇𝒍𝒖𝒆𝒏𝒕_𝒗𝒂𝒍𝒖𝒆> From<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ> for Option<𝓪𝓻𝓫𝓲𝓽𝓻𝓪𝓻𝔂_𝓽𝔂𝓹𝓮> {
    #[inline(always)]
    fn from(_: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_32ᵇⁱᵗ) -> Self {
        None
    }
}

impl<𝓪𝓻𝓫𝓲𝓽𝓻𝓪𝓻𝔂_𝓽𝔂𝓹𝓮: 𝒐𝒑𝒕𝒊𝒐𝒏_𝒇𝒓𝒐𝒎_𝒖𝒏𝒇𝒊𝒍𝒍𝒆𝒅_𝒇𝒍𝒖𝒆𝒏𝒕_𝒗𝒂𝒍𝒖𝒆> From<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ> for Option<𝓪𝓻𝓫𝓲𝓽𝓻𝓪𝓻𝔂_𝓽𝔂𝓹𝓮> {
    #[inline(always)]
    fn from(_: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞_64ᵇⁱᵗ) -> Self {
        None
    }
}

// We want to provide infomation about instruction encoding (prefixes and opcodes) in the type argument to make sure pointless code
// wouldn't be generated (in C++ that was achieved with “if constexpr”, but there are no “if constexpr” in Rust).
//
// This is done with two main helper types: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 and 𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞 (which is just a dummy empty type which
// carries a single byte as part of it's type).
#[allow(non_upper_case_globals)]
pub struct 𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<const 𝓫𝔂𝓽𝓮_𝓿𝓪𝓵𝓾𝓮: u8> {}

// Legacy instructions can include up to five legacy prefixes, plus, possibly, optional 0F, 0F 38, 0F 3A opcode extensions and one
// opcode byte after that.
// Additionally 3DNow! and some SSE/AVX instructions use immediate field as opcode extension.
#[allow(non_snake_case)]
pub struct 𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
    𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝔁𝟯𝘅_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝓸𝓹𝓬𝓸𝓭𝓮 = 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝓲𝓶𝓶𝓮𝓭𝓲𝓪𝓽𝓮_𝓸𝓹𝓬𝓸𝓭𝓮 = 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
> {
    _𝗌𝖾𝗀𝗆𝖾𝗇𝗍_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝖽𝖺𝗍𝖺_𝗌𝗂𝗓𝖾_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝖺𝖽𝖽𝗋𝖾𝗌𝗌_𝗌𝗂𝗓𝖾_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝗋𝖾𝗉ₓ_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝗅𝗈𝖼𝗄_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝗑𝟬𝗙_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝗑𝟯𝘅_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝔁𝟯𝘅_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝗈𝗉𝖼𝗈𝖽𝖾: core::marker::PhantomData<𝓸𝓹𝓬𝓸𝓭𝓮>,
    _𝗂𝗆𝗆𝖾𝖽𝗂𝖺𝗍𝖾_𝗈𝗉𝖼𝗈𝖽𝖾: core::marker::PhantomData<𝓲𝓶𝓶𝓮𝓭𝓲𝓪𝓽𝓮_𝓸𝓹𝓬𝓸𝓭𝓮>,
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊 {
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍 $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼 _𝖺𝗋𝗋𝖺𝗒 0 []);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼 𝖺𝗋𝗋𝖺𝗒 1 [𝖺𝗋𝗋𝖺𝗒[0]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼 𝖺𝗋𝗋𝖺𝗒 2 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼 𝖺𝗋𝗋𝖺𝗒 3 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 4 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 5 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 6 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4], 𝖺𝗋𝗋𝖺𝗒[5]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 7 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4], 𝖺𝗋𝗋𝖺𝗒[5], 𝖺𝗋𝗋𝖺𝗒[6]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 8 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4], 𝖺𝗋𝗋𝖺𝗒[5], 𝖺𝗋𝗋𝖺𝗒[6], 𝖺𝗋𝗋𝖺𝗒[7]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 9 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4], 𝖺𝗋𝗋𝖺𝗒[5], 𝖺𝗋𝗋𝖺𝗒[6], 𝖺𝗋𝗋𝖺𝗒[7], 𝖺𝗋𝗋𝖺𝗒[8]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 10 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4], 𝖺𝗋𝗋𝖺𝗒[5], 𝖺𝗋𝗋𝖺𝗒[6], 𝖺𝗋𝗋𝖺𝗒[7], 𝖺𝗋𝗋𝖺𝗒[8], 𝖺𝗋𝗋𝖺𝗒[9]]);
    };
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x [$([$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt)*])*] [$([$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt)*])*] [𝓸𝓹𝓬𝓸𝓭𝓮 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:ident)*]
               $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮:ident $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮:literal [$($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]) => {
        #[allow(non_upper_case_globals)]
        impl<$($($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)*),*>
        𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<$($($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)*),*>, $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮>
        for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
            #[inline(always)]
            fn emit_prefixes_and_opcodes(
                &mut self, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_array([𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁, $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
            #[inline(always)]
            fn emit_prefixes_rex_and_opcodes(
                &mut self, 𝗋𝖾𝗑: u8, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_array([𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁, $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝗋𝖾𝗑, 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
        }
    };
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x [$([$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt)*])*] [$([$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt)*])*] [𝓸𝓹𝓬𝓸𝓭𝓮 $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:ident)*]
               $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮:ident $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮:literal [$($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]) => {
        #[allow(non_upper_case_globals)]
        impl<$($($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)*),*>
        𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<$($($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)*),*>, $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮>
        for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
            #[inline(always)]
            fn emit_prefixes_and_opcodes(
                &mut self, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_array([$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
            #[inline(always)]
            fn emit_prefixes_rex_and_opcodes(
                &mut self, 𝗋𝖾𝗑: u8, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_array([$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝗋𝖾𝗑, 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
        }
        #[allow(non_upper_case_globals)]
        impl<$($($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)*),*>
        𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<$($($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)*),*>, $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮>
        for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
            #[inline(always)]
            fn emit_segment_prefixes_and_opcodes(
                &mut self, 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_array([𝗌𝖾𝗀𝗆𝖾𝗇𝗍, $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
            #[inline(always)]
            fn emit_segment_prefixes_rex_and_opcodes(
                &mut self, 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8, 𝗋𝖾𝗑: u8, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_array([𝗌𝖾𝗀𝗆𝖾𝗇𝗍, $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝗋𝖾𝗑, 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
        }
    };
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt)*] [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt)*] [$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:ident)*]
                     [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>]) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍
            [[𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓] $($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)* [const 𝓸𝓹𝓬𝓸𝓭𝓮: u8]]
            [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)* [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>] [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞]]
            [𝓸𝓹𝓬𝓸𝓭𝓮 $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼)*]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍
            [[𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓] $($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)* [const 𝓸𝓹𝓬𝓸𝓭𝓮: u8] [const 𝓲𝓶𝓶𝓮𝓭𝓲𝓪𝓽𝓮_𝓸𝓹𝓬𝓸𝓭𝓮: u8]]
            [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)* [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>] [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓲𝓶𝓶𝓮𝓭𝓲𝓪𝓽𝓮_𝓸𝓹𝓬𝓸𝓭𝓮>]]
            [𝓸𝓹𝓬𝓸𝓭𝓮 $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼)* 𝓲𝓶𝓶𝓮𝓭𝓲𝓪𝓽𝓮_𝓸𝓹𝓬𝓸𝓭𝓮]);
    };
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt)*] [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt)*] [$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:ident)*]
                     [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞] $($𝓽𝔂𝓹𝓮𝓼_𝓽𝓸_𝓹𝓻𝓸𝓬𝓮𝓼𝓼:tt)*) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘
            [$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)*]
            [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)* [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞]]
            [$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼)*]
            $($𝓽𝔂𝓹𝓮𝓼_𝓽𝓸_𝓹𝓻𝓸𝓬𝓮𝓼𝓼)*);
    };
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt)*] [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt)*] [$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:ident)*]
                     [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<$𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮:ident>] $($𝓽𝔂𝓹𝓮𝓼_𝓽𝓸_𝓹𝓻𝓸𝓬𝓮𝓼𝓼:tt)*) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘
            [$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)* [const $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮: u8]]
            [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)* [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<$𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮>]]
            [$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼)* $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮]
            $($𝓽𝔂𝓹𝓮𝓼_𝓽𝓸_𝓹𝓻𝓸𝓬𝓮𝓼𝓼)*);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁:tt
                 [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞]) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [] [] [] $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁
            [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞] [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞] [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁:tt
                 $𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [] [] [] $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁 $𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁
            [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞] [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [] [] [] $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁 $𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁
            [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝔁𝟯𝘅_𝓹𝓻𝓮𝓯𝓲𝔁>] [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁
            [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁
            [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    };
    () => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 [𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    }
}

#[allow(non_upper_case_globals)]
pub trait 𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, const 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮: usize>: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓
{
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
    ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞>;
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
    ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞>;
}

#[allow(non_upper_case_globals)]
pub trait 𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, const 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮: usize>: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓
{
    fn emit_segment_prefixes_and_opcodes(
        &mut self, 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
    ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞>;
    fn emit_segment_prefixes_rex_and_opcodes(
        &mut self, 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
    ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞>;
}

𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!();

// Five instructions have versions with register embedded in the opcode: 𝔡𝔢𝔠/𝔦𝔫𝔠/𝔪𝔬𝔳/𝔭𝔬𝔭/𝔭𝔲𝔰𝔥.
// And they can only ever accept data size prefix (0x66) or nothing.
// It's easier to implement precisely two required versions than teach
// 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊 to handle no-opcode instructions.
impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>,
        1>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array(𝖺𝗋𝗋𝖺𝗒)
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>,
        2>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 2],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array(𝖺𝗋𝗋𝖺𝗒)
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 2],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>,
        3>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 3],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array(𝖺𝗋𝗋𝖺𝗒)
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 3],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>,
        5>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 5],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array(𝖺𝗋𝗋𝖺𝗒)
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 5],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>,
        9>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 9],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array(𝖺𝗋𝗋𝖺𝗒)
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 9],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array(
            [
                𝗋𝖾𝗑,
                𝖺𝗋𝗋𝖺𝗒[0],
                𝖺𝗋𝗋𝖺𝗒[1],
                𝖺𝗋𝗋𝖺𝗒[2],
                𝖺𝗋𝗋𝖺𝗒[3],
                𝖺𝗋𝗋𝖺𝗒[4],
                𝖺𝗋𝗋𝖺𝗒[5],
                𝖺𝗋𝗋𝖺𝗒[6],
                𝖺𝗋𝗋𝖺𝗒[7],
                𝖺𝗋𝗋𝖺𝗒[8]
            ]
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x66>,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>,
        1>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([0x66, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([0x66, 𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x66>,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>,
        3>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 3],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([0x66, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2]])
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 3],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([0x66, 𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x66>,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>,
        5>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 5],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([0x66, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4]])
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 5],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([0x66, 𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x0f>,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>,
        1>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([0x0f, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([𝗋𝖾𝗑, 0x0f, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x66>,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x0f>,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>,
        1>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([0x66, 0x0f, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_array([0x66, 𝗋𝖾𝗑, 0x0f, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::unusual_byte_groupings)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: Into<u8>, 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: Into<u8>>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝗋𝗆: 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let 𝗋𝗆: u8 = 𝗋𝗆.into();
                if 𝗋𝖾𝗀 & 0b1000 == 0 && 𝗋𝗆 & 0b1000 == 0 {
                    self.emit_prefixes_and_opcodes([0b11_000_000 | (𝗋𝖾𝗀 << 3) | 𝗋𝗆, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                } else {
                    self.emit_prefixes_rex_and_opcodes(
                        0b0100_0000 | ((𝗋𝖾𝗀 & 0b1000) >> 1) | ((𝗋𝗆 & 0b1000) >> 3),
                        [0b11_000_000 | ((𝗋𝖾𝗀 & 0b111) << 3) | (𝗋𝗆 & 0b111), $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*],
                    )
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝟴 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::unusual_byte_groupings)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: Into<u8>, 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: Into<u8>>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝗋𝗆: 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let 𝗋𝗆: u8 = 𝗋𝗆.into();
                if 𝗋𝖾𝗀 < 0b11 && 𝗋𝗆 < 0b11 {
                    self.emit_prefixes_and_opcodes([0b11_000_000 | (𝗋𝖾𝗀 << 3) | 𝗋𝗆, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                } else {
                    self.emit_prefixes_rex_and_opcodes(
                        0b0100_0000 | ((𝗋𝖾𝗀 & 0b1000) >> 1) | ((𝗋𝗆 & 0b1000) >> 3),
                        [0b11_000_000 | ((𝗋𝖾𝗀 & 0b111) << 3) | (𝗋𝗆 & 0b111), $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*],
                    )
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝖜 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::unusual_byte_groupings)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: Into<u8>, 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: Into<u8>>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝗋𝗆: 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let 𝗋𝗆: u8 = 𝗋𝗆.into();
                self.emit_prefixes_rex_and_opcodes(
                    0b0100_1000 | ((𝗋𝖾𝗀 & 0b1000) >> 1) | ((𝗋𝗆 & 0b1000) >> 3),
                    [0b11_000_000 | ((𝗋𝖾𝗀 & 0b111) << 3) | (𝗋𝗆 & 0b111), $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*],
                )
            }
         )*
    }
}

pub trait 𝒆𝒎𝒊𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼>:
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10>
{
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
        emit_legacy_reg_rm_instruction() => [],
        emit_legacy_reg_rm_instruction_with_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_rm_instruction_with_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_rm_instruction_with_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_rm_instruction_with_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_rm_instruction_with_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_rm_instruction_with_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_rm_instruction_with_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_rm_instruction_with_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝟴! {
        emit_legacy_reg_rm_instruction_with_rex8() => [],
        emit_legacy_reg_rm_instruction_with_rex8_and_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_rm_instruction_with_rex8_and_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_rm_instruction_with_rex8_and_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_rm_instruction_with_rex8_and_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝖜! {
        emit_legacy_reg_rm_instruction_with_rexw() => [],
        emit_legacy_reg_rm_instruction_with_rexw_and_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_rm_instruction_with_rexw_and_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_rm_instruction_with_rexw_and_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_rm_instruction_with_rexw_and_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
}

impl<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮:
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10>>
𝒆𝒎𝒊𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼>
for 𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝟴𝟬𝟴𝟲_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: Into<u8>, 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: Into<u8>, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋𝖾𝗌𝗌: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
                                      super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_𝐛𝐚𝐬𝐞_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_16ᵇⁱᵗ,
                                      super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_𝐢𝐧𝐝𝐞𝐱_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_16ᵇⁱᵗ,
                                      i16,
                                      𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let 𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍: super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_8086_𝐝𝐢𝐬𝐜𝐫𝐢𝐦𝐢𝐧𝐚𝐧𝐭 = (
                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖻𝖺𝗌𝖾,
                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗂𝗇𝖽𝖾𝗑,
                ).into();
                if let Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍) = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖾𝗀𝗆𝖾𝗇𝗍 {
                    let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                    if 𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 == super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_8086_𝐝𝐢𝐬𝐜𝐫𝐢𝐦𝐢𝐧𝐚𝐧𝐭::𝔫𝔬𝔫𝔢_𝔫𝔬𝔫𝔢 {
                        self.emit_segment_prefixes_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_110 | (𝗋𝖾𝗀 << 3), 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                    } else {
                        let 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 = super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝔞𝔡𝔡𝔯𝔢𝔰𝔰_8086_𝔡𝔦𝔰𝔠𝔯𝔦𝔪𝔦𝔫𝔞𝔫𝔱_𝔱𝔬_𝔪𝔬𝔡𝔯𝔪[𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 as usize];
                        if 𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 != super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_8086_𝐝𝐢𝐬𝐜𝐫𝐢𝐦𝐢𝐧𝐚𝐧𝐭::𝔟𝔭_𝔫𝔬𝔫𝔢 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3), $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i16 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_000 | 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3), 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                        } else {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                     0b10_000_000 | 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3),
                                     𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                     (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                     $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                            )
                        }
                    }
                } else if 𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 == super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_8086_𝐝𝐢𝐬𝐜𝐫𝐢𝐦𝐢𝐧𝐚𝐧𝐭::𝔫𝔬𝔫𝔢_𝔫𝔬𝔫𝔢 {
                    self.emit_prefixes_and_opcodes(
                        [0b00_000_110 | (𝗋𝖾𝗀 << 3), 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                } else {
                    let 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 = super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝔞𝔡𝔡𝔯𝔢𝔰𝔰_8086_𝔡𝔦𝔰𝔠𝔯𝔦𝔪𝔦𝔫𝔞𝔫𝔱_𝔱𝔬_𝔪𝔬𝔡𝔯𝔪[𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 as usize];
                    if 𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 != super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_8086_𝐝𝐢𝐬𝐜𝐫𝐢𝐦𝐢𝐧𝐚𝐧𝐭::𝔟𝔭_𝔫𝔬𝔫𝔢 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                        self.emit_prefixes_and_opcodes([𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3), $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                    } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i16 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                        self.emit_prefixes_and_opcodes(
                            [0b01_000_000 | 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3), 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                    } else {
                        self.emit_prefixes_and_opcodes(
                            [
                                0b10_000_000 | 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3),
                                𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ]
                        )
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝟴𝟬𝟯𝟴𝟲_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮 : Default + Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋𝖾𝗌𝗌: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                match (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗂𝗇𝖽𝖾𝗑) {
                    (None, None, None) => self.emit_prefixes_and_opcodes(
                        [
                            0b00_000_101 | (𝗋𝖾𝗀 << 3),
                            𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                            (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                            (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                            (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                            $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                        ],
                    ),
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        self.emit_segment_prefixes_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            [
                                0b00_000_101 | (𝗋𝖾𝗀 << 3),
                                𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_and_opcodes([0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_and_opcodes([0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_and_opcodes(
                                    [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_and_opcodes(
                                    [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        self.emit_prefixes_and_opcodes(
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        self.emit_segment_prefixes_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_prefixes_and_opcodes(
                                [
                                     0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                     0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                     $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                           )
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            self.emit_prefixes_and_opcodes(
                                [
                                     0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                     0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                     𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                     $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                            )
                        } else {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                             )
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮 : Default + Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋𝖾𝗌𝗌: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let mut 𝗋𝖾𝗑: u8 = 0b0100_0000 | ((𝗋𝖾𝗀 & 0b1000) >> 1);
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀 & 0b111;
                match (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗂𝗇𝖽𝖾𝗑) {
                    (None, None, None) => {
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_prefixes_and_opcodes([0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_prefixes_and_opcodes([0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_prefixes_and_opcodes(
                                        [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_prefixes_and_opcodes(
                                        [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_100_100,
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(𝗋𝖾𝗑, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_100_100,
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                         0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                         0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                         $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ]
                                )
                            } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                         0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                         0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                         𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                         $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ]
                                )
                            } else {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ]
                                )
                            } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                     0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                     0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                     $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                            )
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝟴 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮 : Default + Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋𝖾𝗌𝗌: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let mut 𝗋𝖾𝗑: u32 = 0b0100_0000 | ((𝗋𝖾𝗀 as u32 & 0b1000) >> 1) | (((𝗋𝖾𝗀 > 0b11) as u32) << 8);
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀 & 0b111;
                match (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗂𝗇𝖽𝖾𝗑) {
                    (None, None, None) => {
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 as u32 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_prefixes_and_opcodes([0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_prefixes_and_opcodes([0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_prefixes_and_opcodes(
                                        [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_prefixes_and_opcodes(
                                        [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_100_100,
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑 as u8, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑 as u8, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑 as u8, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑 as u8, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 as u32 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_100_100,
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑 as u8, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑 as u8, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    𝗋𝖾𝗑 as u8,
                                    [
                                        0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_100_100,
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ]
                                )
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    𝗋𝖾𝗑 as u8,
                                    [
                                        0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ]
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 as u32 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 as u32 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 as u32 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 as u32 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 as u32 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 as u32 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝖜 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮 : Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮 : Default + Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋𝖾𝗌𝗌: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let mut 𝗋𝖾𝗑: u8 = 0b0100_1000 | ((𝗋𝖾𝗀 & 0b1000) >> 1);
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀 & 0b111;
                match (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗂𝗇𝖽𝖾𝗑) {
                    (None, None, None) => self.emit_prefixes_rex_and_opcodes(
                        𝗋𝖾𝗑,
                        [
                            0b00_000_100 | (𝗋𝖾𝗀 << 3),
                            0b00_100_101,
                            𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                            (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                            (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                            (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                            $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                        ],
                    ),
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        self.emit_segment_prefixes_rex_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            𝗋𝖾𝗑,
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_100_101,
                                𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8, 
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(𝗋𝖾𝗑, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(𝗋𝖾𝗑, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        self.emit_prefixes_rex_and_opcodes(
                            𝗋𝖾𝗑,
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        self.emit_segment_prefixes_rex_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            𝗋𝖾𝗑,
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else if 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋𝖾𝗌𝗌.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                }
            }
         )*
    }
}

pub trait 𝒆𝒎𝒊𝒕_𝒎𝒆𝒎𝒐𝒓𝒚_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼>:
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10>
{
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝟴𝟬𝟴𝟲_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
        emit_legacy_reg_address_8086_memory_instruction() => [],
        emit_legacy_reg_address_8086_memory_instruction_with_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_8086_memory_instruction_with_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_8086_memory_instruction_with_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_8086_memory_instruction_with_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝟴𝟬𝟯𝟴𝟲_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
        emit_legacy_reg_address_80386_memory_instruction() => [],
        emit_legacy_reg_address_80386_memory_instruction_with_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_80386_memory_instruction_with_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_80386_memory_instruction_with_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_80386_memory_instruction_with_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
        emit_legacy_reg_address_ₓ86_64_memory_instruction() => [],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝟴! {
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8() => [],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝖜! {
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw() => [],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
}

impl<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮:
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10>>
𝒆𝒎𝒊𝒕_𝒎𝒆𝒎𝒐𝒓𝒚_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼>
for 𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {}
